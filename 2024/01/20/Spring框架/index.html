<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf8"/>
    <meta name="viewport" content="initial-scale=1.0, width=device-width"/>
    <title>
      
        Spring框架 | 芋圆明天不困
      
    </title>
    <meta name="description" content=""/>
    <meta name="keywords" content=""/>
    
      <link rel="apple-touch-icon"
            sizes="180x180"
            href="/images/apple-touch-icon.png"/>
    
    
      <link rel="icon"
            type="image/png"
            sizes="32x32"
            href="/images/favicon-32x32.png"/>
    
    
      <link rel="icon"
            type="image/png"
            sizes="16x16"
            href="/images/favicon-16x16.png"/>
    
    
      <link rel="mask-icon"
            href="/images/logo.svg"
            color=""/>
    
    
    
      
  <style>
    @font-face {
        font-family:sourceHanSerif;
        src: url(/font/regular.ttf);
        font-weight: regular;
    }
  </style>

  <style>
    @font-face {
        font-family:sourceHanSerif;
        src: url(/font/bold.ttf);
        font-weight: bold;
    }
  </style>


    
    <link rel="stylesheet"
          type="text/css"
          href='/css/layout.css'/>
    
    
  <link rel="stylesheet" type="text/css" href="/css/post.css" />
  

  <meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div class="head">
      <div class="nav">
        <a href='/' class="nav-logo">
          <img alt="logo" height="60px" width="60px" src="/images/logo.svg"/>
        </a>
        <input id="navBtn" type="checkbox"/>
        <div class="nav-menu">
          
            
              <a class="nav-menu-item" href="/CS">技术</a>
            
              <a class="nav-menu-item" href="/Others">杂七杂八</a>
            
          
          
        </div>
        <label class="nav-btn" for="navBtn"></label>
      </div>
    </div>
    <div class="body">
      
  <article class="post-content">
    <div class="post-inner--toc">
      <div class="post-content__head">
        <div class="post-title">Spring框架</div>
        <div class="post-info">
          
  <a href="/tags/Java/" class="post-tag">#Java</a><a href="/tags/%E5%BC%80%E5%8F%91/" class="post-tag">#开发</a><a href="/tags/SSM/" class="post-tag">#SSM</a>


          <span class="post-date">2024-01-20</span>
        </div>
      </div>
      
        <aside class="toc-outer">
          <div class="toc-title">目录</div>
          <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E4%B8%80%E3%80%81SpringIOC%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="post-toc-text">一、SpringIOC容器和核心概念</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E4%BA%8C%E3%80%81SpringIOC%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="post-toc-text">二、SpringIOC的实践与应用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-%E5%9F%BA%E4%BA%8EXML%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8FBean%EF%BC%88%E7%BB%84%E4%BB%B6%EF%BC%89%E7%AE%A1%E7%90%86"><span class="post-toc-text">1.基于XML配置方式Bean（组件）管理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9ABean%E4%BF%A1%E6%81%AF%E5%A3%B0%E6%98%8E%E9%85%8D%E7%BD%AEIOC"><span class="post-toc-text">实验一：Bean信息声明配置IOC</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9ABean%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E9%85%8D%E7%BD%AE%EF%BC%88DI%EF%BC%89"><span class="post-toc-text">实验二：Bean依赖注入配置（DI）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9AIOC%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="post-toc-text">实验三：IOC容器的创建和使用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9A%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%9Abean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E9%85%8D%E7%BD%AE"><span class="post-toc-text">实验四：高级特性：bean的作用域和周期方法配置</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%94%EF%BC%9A%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%9AFactoryBean%E7%9A%84%E7%89%B9%E6%80%A7%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="post-toc-text">实验五：高级特性：FactoryBean的特性和使用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%85%AD%EF%BC%9A%E5%9F%BA%E4%BA%8EXML%E6%96%B9%E5%BC%8F%E6%95%B4%E5%90%88%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6"><span class="post-toc-text">实验六：基于XML方式整合三层架构组件</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-%E5%9F%BA%E4%BA%8E-%E6%B3%A8%E8%A7%A3-%E6%96%B9%E5%BC%8F%E7%AE%A1%E7%90%86Bean"><span class="post-toc-text">2.基于 注解 方式管理Bean</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9ABean%E6%B3%A8%E8%A7%A3%E6%A0%87%E8%AE%B0%E5%92%8C%E6%89%AB%E6%8F%8F"><span class="post-toc-text">实验一：Bean注解标记和扫描</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9ABean%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="post-toc-text">实验二：Bean作用域和周期方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9ABean%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%EF%BC%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%EF%BC%88DI%EF%BC%89"><span class="post-toc-text">实验三：Bean属性赋值，引用类型自动装配（DI）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9ABean%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%EF%BC%88DI%EF%BC%89"><span class="post-toc-text">实验四：Bean属性赋值：基本类型属性赋值（DI）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93"><span class="post-toc-text">总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-%E5%9F%BA%E4%BA%8E-%E9%85%8D%E7%BD%AE%E7%B1%BB-%E6%96%B9%E5%BC%8F%E7%AE%A1%E7%90%86Bean"><span class="post-toc-text">3.基于 配置类 方式管理Bean</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A-Bean%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6"><span class="post-toc-text">实验二：@Bean定义组件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%9A-Bean%E6%B3%A8%E8%A7%A3%E7%BB%86%E8%8A%82"><span class="post-toc-text">实验三：高级特性：@Bean注解细节</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9A%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%9A-Import%E6%89%A9%E5%B1%95"><span class="post-toc-text">实验四：高级特性：@Import扩展</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="post-toc-text">总结</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#XML%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93"><span class="post-toc-text">XML方式配置总结</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#XML-%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93"><span class="post-toc-text">XML+注解方式配置总结</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%8C%E5%85%A8%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93"><span class="post-toc-text">完全注解方式配置总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%95%B4%E5%90%88%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83"><span class="post-toc-text">整合测试环境</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E4%B8%89%E3%80%81Spring-AOP%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B"><span class="post-toc-text">三、Spring AOP面向切面编程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">1.代理模式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-Spring-AOP%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">2.Spring AOP框架介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-Spring-AOP%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%92%8C%E7%BB%86%E8%8A%82"><span class="post-toc-text">3.Spring AOP基于注解方法实现和细节</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">(1)初步实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-%E8%8E%B7%E5%8F%96%E9%80%9A%E7%9F%A5%E7%BB%86%E8%8A%82%E4%BF%A1%E6%81%AF"><span class="post-toc-text">(2)获取通知细节信息</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="post-toc-text">(3)切点表达式语法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E5%8F%8A%E5%88%87%E9%9D%A2%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%BE%E7%BD%AE"><span class="post-toc-text">(4)环绕通知及切面优先级设置</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-Spring-AOP%E5%9F%BA%E4%BA%8EXML%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="post-toc-text">4.Spring AOP基于XML方法实现（了解）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-Spring-AOP%E5%AF%B9%E8%8E%B7%E5%8F%96Bean%E7%9A%84%E5%BD%B1%E5%93%8D%E7%90%86%E8%A7%A3"><span class="post-toc-text">5.Spring AOP对获取Bean的影响理解</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%9B%9B%E3%80%81%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="post-toc-text">四、声明式事务</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7"><span class="post-toc-text">事务属性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8F%AA%E8%AF%BB"><span class="post-toc-text">只读</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%B6%85%E5%87%BA%E6%97%B6%E9%97%B4"><span class="post-toc-text">超出时间</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%BC%82%E5%B8%B8"><span class="post-toc-text">事务异常</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="post-toc-text">事务隔离级别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="post-toc-text">事务传播行为</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Spring%E6%80%BB%E7%BB%93"><span class="post-toc-text">Spring总结</span></a></li></ol>
          <a href="#" class="toc-top">回到顶部</a>
        </aside>
      
      <div class="post-content__body">
        
          <div class="post-gallery">
            
          </div>
        
        <p><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/zyx_images/202401201814430.png"></p>
<p><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/zyx_images/202401201814506.png"></p>
<p>Springboot是将ssm整合的一个框架。</p>
<p>框架 &#x3D; jar包（有功能）+配置文件（定制化）<br><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/zyx_images/202401201818757.png" width="50%" height="50%"></p>
<ul>
<li><p><strong>Spring</strong><br>广义的 Spring：Spring 技术栈（全家桶）。<br>广义上的 Spring 泛指<strong>以 Spring Framework 为基础的 Spring 技术栈。</strong></p>
</li>
<li><p>SpringFramework</p>
<img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/zyx_images/202401201823569.png" width="50%" height="50%"></li>
</ul>
<table>
<thead>
<tr>
<th>功能模块</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Core Container</strong></td>
<td>核心容器，在 Spring 环境下使用任何功能都必须基于IOC容器。</td>
</tr>
<tr>
<td>AOP&amp;Aspects</td>
<td>面向切面编程</td>
</tr>
<tr>
<td>TX</td>
<td>声明式事务管理</td>
</tr>
<tr>
<td>Spring MVC</td>
<td>提供了面向Web应用程序的集成功能</td>
</tr>
</tbody></table>
<ul>
<li>SpringFramework优势</li>
</ul>
<ol>
<li><strong>丰富的生态系统</strong>：支持许多模块和库，如 Spring Boot、Spring Security、Spring Cloud 等等，可以帮助开发人员快速构建高可靠性的企业应用程序。</li>
<li><strong>模块化的设计</strong>：框架组件之间的松散耦合和模块化设计使得 Spring Framework 具有良好的可重用性、可扩展性和可维护性。</li>
<li><strong>简化 Java 开发</strong>：Spring Framework 简化了 Java 开发，提供了各种工具和 API，可以降低开发复杂度和学习成本。同时，Spring Framework 支持各种应用场景，包括 Web 应用程序、RESTful API、消息传递、批处理等等。</li>
</ol>
<h1 id="一、SpringIOC容器和核心概念"><a href="#一、SpringIOC容器和核心概念" class="headerlink" title="一、SpringIOC容器和核心概念"></a>一、SpringIOC容器和核心概念</h1><ul>
<li>组件是可以<strong>复用</strong>的java<strong>对象</strong></li>
<li>组件可以完全交给Spring 框架进行管理，Spring框架替代了程序员原有的new对象和对象属性赋值动作等！</li>
</ul>
<p>交给Spring框架的优势：<br>降低了组件之间的耦合性，Spring IoC容器通过依赖注入机制，将组件之间的依赖关系削弱；提高了代码的可重用性和可维护性；方便了配置和管理；交给Spring管理的对象（组件），方<strong>可享受Spring框架的其他功能（AOP,声明事务管理TX）</strong>等</p>
<ul>
<li>SpringIOC容器<br>普通容器：只能存储数据（数组，list，set）<br>复杂容器：存储和管理数据（创建对象，调用方法）</li>
</ul>
<p>总结：<strong>Spring管理组件的容器，就是一个复杂容器，不仅存储组件，也可以管理组件之间依赖关系，并且创建和销毁组件等。</strong></p>
<p>配置元数据以 <strong>XML、Java 注解或 Java 代码形式表现</strong>。它允许表达组成应用程序的组件以及这些组件之间丰富的相互依赖关系。</p>
<ul>
<li>SpringIOC的接口和实现类</li>
</ul>
<p>BeanFactory接口是SpringIOC容器的标准化超接口；<br><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。它扩展了以下功能：</p>
<ul>
<li>更容易与 Spring 的 AOP 功能集成</li>
<li>消息资源处理（用于国际化）</li>
<li>特定于应用程序给予此接口实现，例如Web 应用程序的 <code>WebApplicationContext</code></li>
</ul>
<p>BeanFactory 提供了配置框架和基本功能；ApplicationContext 添加了更多特定于企业的功能</p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ClassPathXmlApplicationContext</strong></td>
<td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td>FileSystemXmlApplicationContext</td>
<td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td>AnnotationConfigApplicationContext</td>
<td>通过读取Java配置类创建 IOC 容器对象</td>
</tr>
<tr>
<td>WebApplicationContext</td>
<td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td>
</tr>
</tbody></table>
<p><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/zyx_images/202401202014826.png"></p>
<p>SpringIOC容器管理配置方式：XML配置方式（最早）、<strong>注解方式和Java配置类方式（常用）</strong></p>
<p>总结：</p>
<ul>
<li><p><strong>IoC容器</strong><br>Spring IoC 容器，负责实例化、配置和组装 bean（组件）核心容器。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。</p>
</li>
<li><p><strong>IoC（Inversion of Control）控制反转</strong><br>IoC 主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序直接创建该对象，而是由 IoC 容器来创建和管理，即<strong>控制权由应用程序转移到 IoC 容器</strong>中，也就是“反转”了控制权。这种方式基本上是通过<strong>依赖查找</strong>的方式来实现的，即 IoC 容器维护着构成应用程序的对象，并负责创建这些对象。</p>
</li>
<li><p><strong>DI (Dependency Injection) 依赖注入</strong><br>DI 是指在组件之间传递依赖关系的过程中，<strong>将依赖关系在容器内部进行处理</strong>，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在 Spring 中，DI 是通过<strong>XML 配置文件或注解的方式</strong>实现的。它提供了三种形式的依赖注入：<strong>构造函数注入、Setter 方法注入和接口注入</strong>。</p>
</li>
</ul>
<h1 id="二、SpringIOC的实践与应用"><a href="#二、SpringIOC的实践与应用" class="headerlink" title="二、SpringIOC的实践与应用"></a>二、SpringIOC的实践与应用</h1><p>步骤：</p>
<ol>
<li>编写配置信息，配置文件(xml,注解，配置)，组件类信息和组件之间的引用关系<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> [<span class="hljs-attr">1</span>] <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span> [<span class="hljs-attr">2</span>]&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li>实例化IOC容器对象(ApplicationContext 构造函数)</li>
<li>在Java代码中获取组件（getBean）</li>
</ol>
<h2 id="1-基于XML配置方式Bean（组件）管理"><a href="#1-基于XML配置方式Bean（组件）管理" class="headerlink" title="1.基于XML配置方式Bean（组件）管理"></a>1.基于XML配置方式Bean（组件）管理</h2><p>定义xml文件，声明组件类信息，给Spring的IOC容器管理</p>
<center><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/zyx_images/202401211956124.png" width="50%" height="50%"></center>

<h3 id="实验一：Bean信息声明配置IOC"><a href="#实验一：Bean信息声明配置IOC" class="headerlink" title="实验一：Bean信息声明配置IOC"></a>实验一：Bean信息声明配置IOC</h3><p>实例化对象：</p>
<ul>
<li><strong>构造函数实例化（无参构造函数，有参构造函数9（DI））</strong></li>
<li><strong>工厂模式实例化（静态工厂，非静态工厂）</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--    1.无参构造函数实例化组件</span><br><span class="hljs-comment">bean一个组件信息，id组件标识，class组件的类的全限定符</span><br><span class="hljs-comment">一个组件类-声名2个组件信息-默认单例模式-实例化2个组件对象</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;happyComponent&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.carrie.ioc01.HappyComponent&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--    2.静态工厂类 声明工厂方法</span><br><span class="hljs-comment">factory-method 静态工厂方法（必须静态方法）</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clientService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.carrie.ioc01.ClientService&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createInstance&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--    3.非静态工厂，实例工厂</span><br><span class="hljs-comment">配置工厂类的组件信息;</span><br><span class="hljs-comment">指定非静态工厂对象(组件)和方法名(必须非静态)，配置生成的ioc信息</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;defaultServiceLocator&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.carrie.ioc01.DefaultServiceLocator&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clientService2&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;defaultServiceLocator&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createClientServiceInstance&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="实验二：Bean依赖注入配置（DI）"><a href="#实验二：Bean依赖注入配置（DI）" class="headerlink" title="实验二：Bean依赖注入配置（DI）"></a>实验二：Bean依赖注入配置（DI）</h3><p>实现IOC容器中Bean之间的引用（依赖注入配置）</p>
<ul>
<li><strong>基于构造函数的依赖注入（单个构造参数，多个参数的构造函数）</strong></li>
<li><strong>基于Setter的依赖注入</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--引用和被引用的组件，必须都在ioc容器--&gt;</span><br><span class="hljs-comment">&lt;!--    1.单个构造参数注入--&gt;</span><br><span class="hljs-comment">&lt;!--    写的顺序没有影响，高级容器，先创建所有的对象，再进行属性赋值--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.carrie.ioc02.UserDao&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.carrie.ioc02.UserService&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--        需要传入构造参数</span><br><span class="hljs-comment">constructor-arg:构造参数传值，value直接属性值（int，String），ref引用其他的bean（id值）</span><br><span class="hljs-comment">--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>  <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--    2.多个构造参数--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.carrie.ioc02.UserService&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--        构造参数的顺序--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;zyx&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--构造参数的名称写（推荐！！！！）--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.carrie.ioc02.UserService&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;zyx&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--   构造参数的下标，index --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.carrie.ioc02.UserService&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;zyx&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    3.触发setter方法注入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;movieFineder&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.carrie.ioc02.MovieFinder&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;simpleMovieLister&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.carrie.ioc02.SimpleMovieLister&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--       setter方法去掉set首字母小写的值(本质找的是方法名！！！)</span><br><span class="hljs-comment">value/ref 二选一</span><br><span class="hljs-comment">--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;movieName&quot;</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;下雪了&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;movieFinder&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;movieFineder&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="实验三：IOC容器的创建和使用"><a href="#实验三：IOC容器的创建和使用" class="headerlink" title="实验三：IOC容器的创建和使用"></a>实验三：IOC容器的创建和使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.carrie.test;<br><br><span class="hljs-keyword">import</span> com.carrie.ioc03.HappyComponent;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringIoCTEst</span> &#123;<br><span class="hljs-comment">//    创建IoC容器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createIoC</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        接口：BeanFactory；ApplicationContext，扩展的接口</span><br><span class="hljs-comment">        实现类：</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//法1.直接创建文件</span><br>        ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;spring-03.xml&quot;</span>);<br>        <span class="hljs-comment">//法2.先创建ioc容器，在指定配置文件(外部配置)</span><br>        <span class="hljs-comment">//源码的配置过程</span><br>        ClassPathXmlApplicationContext applicationContext1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>();<br>        applicationContext1.setConfigLocations(<span class="hljs-string">&quot;spring-03.xml&quot;</span>);<br>        applicationContext1.refresh();<span class="hljs-comment">//刷新才有效</span><br>    &#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">从IoC容器中获取组件</span><br><span class="hljs-comment"> */</span><span class="hljs-meta">@Test</span><br><span class="hljs-comment">//方法前加@Test，可以测试</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getBeanFromIoC</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//创建ioc容器</span><br>        ClassPathXmlApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>();<br>        applicationContext.setConfigLocations(<span class="hljs-string">&quot;spring-03.xml&quot;</span>);<br>        applicationContext.refresh();<br>        <span class="hljs-comment">//1.beanID,返回类型是Object，需要强转</span><br>        <span class="hljs-type">HappyComponent</span> <span class="hljs-variable">happyComponent</span> <span class="hljs-operator">=</span> (HappyComponent) applicationContext.getBean(<span class="hljs-string">&quot;happyComponent&quot;</span>);<br>        <span class="hljs-comment">//2.beanID，指定Bean的类型</span><br>        <span class="hljs-type">HappyComponent</span> <span class="hljs-variable">happyComponent1</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;happyComponent&quot;</span>, HappyComponent.class);<br>        <span class="hljs-comment">//3.根据类型获取</span><br>        <span class="hljs-comment">//TODO：只能有一个同类型的bean，多个会出现异常</span><br>        <span class="hljs-comment">//TODO：ioc配置一定是实现类，但可以根据接口类型赋值 instanceOf ioc容器的类型==true</span><br>        <span class="hljs-type">HappyComponent</span> <span class="hljs-variable">happyComponent2</span> <span class="hljs-operator">=</span> applicationContext.getBean(HappyComponent.class);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        (HappyComponent implement A)</span><br><span class="hljs-comment">        A happyComponent2 = applicationContext.getBean(A.class);</span><br><span class="hljs-comment">        happyComponent2.dowork();</span><br><span class="hljs-comment">         */</span><br>    System.out.println(happyComponent==happyComponent1);<br>    System.out.println(happyComponent2==happyComponent1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="实验四：高级特性：bean的作用域和周期方法配置"><a href="#实验四：高级特性：bean的作用域和周期方法配置" class="headerlink" title="实验四：高级特性：bean的作用域和周期方法配置"></a>实验四：高级特性：bean的作用域和周期方法配置</h3><ul>
<li>周期方法<br>周期方法：到对应时间才<strong>主动调用</strong>，只能等待和编写对应的逻辑<br>在组件类中定义方法，然后当IoC容器<strong>实例化</strong>和<strong>销毁组件对象</strong>的时候进行调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaBean</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    必须是public，void，无参数;</span><br><span class="hljs-comment">    命名随意</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;JavaBean.init&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//销毁</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;destroy&quot;</span>);<br>    &#125;<br>&#125;<br><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">    测试ioc容器的初始化和destroy</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_04</span><span class="hljs-params">()</span>&#123;<br>     ClassPathXmlApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;spring-04.xml&quot;</span>);<br>     <span class="hljs-comment">//ioc容器调用destroy</span><br>        <span class="hljs-comment">// 正常结束ioc容器</span><br>        applicationContext.close();<br>    &#125;<br>  <br></code></pre></td></tr></table></figure>

<ul>
<li>作用域<br>准备好组件类，配置文件，到ioc容器（java文件），需要将配置文件转化为BeanDefinition类，再反射实例化得到组件对象，检查BeanDefinition中的scope【单例（默认）或多例】<br>单例（singleton），外部多次调用都是一个对象；多例（prototype），调用一次就是一个新的对象</li>
</ul>
<ol>
<li>作用域可选值<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
<th>创建对象的时机</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>在 IOC 容器中，这个 bean 的对象始终为单实例</td>
<td><strong>IOC 容器初始化时</strong></td>
<td>是</td>
</tr>
<tr>
<td>prototype</td>
<td>这个 bean 在 IOC 容器中有多个实例</td>
<td><strong>获取 bean 时（getBean）</strong></td>
<td>否</td>
</tr>
</tbody></table>
</li>
</ol>
<p>如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
<th>创建对象的时机</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>request</td>
<td>请求范围内有效的实例</td>
<td>每次请求</td>
<td>否</td>
</tr>
<tr>
<td>session</td>
<td>会话范围内有效的实例</td>
<td>每次会话</td>
<td>否</td>
</tr>
</tbody></table>
<h3 id="实验五：高级特性：FactoryBean的特性和使用"><a href="#实验五：高级特性：FactoryBean的特性和使用" class="headerlink" title="实验五：高级特性：FactoryBean的特性和使用"></a>实验五：高级特性：FactoryBean的特性和使用</h3><p>FactoryBean：标准化工厂<br>重写getObject（）：编写实例化逻辑（配置文件中，不用写factory-method，只需要配置工厂类即可）</p>
<p><strong>用于配置复杂的Bean对象，创建过程存储在FactoryBean的getObject方法</strong></p>
<p><code>FactoryBean&lt;T&gt;</code> 接口提供三种方法：</p>
<ul>
<li><code>T getObject()</code>:<br>  返回此工厂创建的对象的实例。该返回值会被存储到IoC容器！</li>
<li><code>boolean isSingleton()</code>:<br>  如果此 <code>FactoryBean</code> 返回单例，则返回 <code>true</code> ，否则返回 <code>false</code> 。此方法的默认实现返回 <code>true</code> （注意，lombok插件使用，可能影响效果）。</li>
<li><code>Class&lt;?&gt; getObjectType()</code>: 返回 <code>getObject()</code> 方法返回的对象类型，如果事先不知道类型，则返回 <code>null</code> 。</li>
</ul>
<ol>
<li>FactoryBean使用场景<ol>
<li>代理类的创建</li>
<li>第三方框架整合</li>
<li>复杂对象实例化等</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassPathXmlApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;spring-05.xml&quot;</span>);<br>        <span class="hljs-type">JavaBean</span> <span class="hljs-variable">javaBean</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;javaBean&quot;</span>, JavaBean.class);<br>        <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>FactoryBean也在IoC容器，标识符为 &amp;id</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">javaBean2</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;&amp;javaBean&quot;</span>);<br></code></pre></td></tr></table></figure>

<ol>
<li>FactoryBean和BeanFactory区别</li>
</ol>
<ul>
<li><strong>FactoryBean</strong><br>Spring 中一种<strong>特殊的 bean</strong>，可以在<strong>getObject() 工厂方法自定义的逻辑创建Bean</strong>。是一种能够生产其他 Bean 的 Bean。FactoryBean 在容器启动时被创建，而在实际使用时则是通过<strong>调用 getObject() 方法来得到其所生产的 Bean</strong>。FactoryBean 可以自定义任何所需的初始化逻辑，生产出一些定制化的 bean。<br>一般情况下，<strong>整合第三方框架</strong>，都是通过定义FactoryBean实现！！！</li>
<li><strong>BeanFactory</strong><br><strong>Spring 框架的基础</strong>，其作为一个<strong>定义了容器基本行为的顶级接口</strong>，例如管理 bean 的生命周期、配置文件的加载和解析、bean 的装配和依赖注入等。BeanFactory 接口提供了访问 bean 的方式，例如 getBean() 方法获取指定的 bean 实例。它可以从不同的来源（例如 Mysql 数据库、XML 文件、Java 配置类等）获取 bean 定义，并将其转换为 bean 实例。同时，BeanFactory 还包含很多子类（例如，ApplicationContext 接口）提供了额外的强大功能。</li>
</ul>
<p>总的来说，FactoryBean 和 BeanFactory 的区别主要在于前者是用于<strong>创建 bean 的接口</strong>，它提供了更加灵活的初始化定制功能，而后者是用于<strong>管理 bean 的框架基础接口</strong>，提供了基本的<strong>容器功能和 bean 生命周期管理</strong>。</p>
<h3 id="实验六：基于XML方式整合三层架构组件"><a href="#实验六：基于XML方式整合三层架构组件" class="headerlink" title="实验六：基于XML方式整合三层架构组件"></a>实验六：基于XML方式整合三层架构组件</h3><ul>
<li><p><strong>JdbcTemplate</strong><br>为了在特定领域帮助我们简化代码，Spring 封装了很多 『Template』形式的模板类。例如： JdbcTemplate、RedisTemplate、RestTemplate等等。</p>
</li>
<li><p>java代码连接数据库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">       该类仅简化数据库的增删改查的操作，不提供连接池；需要DruidDataSource负责连接的创建和数据库驱动的注册</span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-comment">//创建连接池对象</span><br>       DruidDataSource dataSource=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>       dataSource.setUrl(<span class="hljs-string">&quot;jdbc:mysql:///studb&quot;</span>); <span class="hljs-comment">//数据库地址：jdbc:mysql://localhost:3306/studb</span><br>       dataSource.setDriverClassName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<span class="hljs-comment">//jdbc驱动</span><br>       dataSource.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>       dataSource.setPassword(<span class="hljs-string">&quot;zyx123456&quot;</span>);<br>       <span class="hljs-comment">//实例化对象</span><br>       JdbcTemplate jdbcTemplate=<span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTemplate</span>();<br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       jdbcTemplate.update() DDL,DML,DCL……非查询语句</span><br><span class="hljs-comment">       jdbcTemplate.queryForObject() DQl 查询单个对象</span><br><span class="hljs-comment">       jdbcTemplate.query() DQl 查询集合</span><br><span class="hljs-comment">        */</span><br></code></pre></td></tr></table></figure>

</li>
<li><p>xml配置数据库</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    读取外部配置文件.properties =&gt; value =&quot;$&#123;key&#125;&quot;</span><br><span class="hljs-comment">&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;,classpath:其他配置</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--bean相当于new--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;atguigu.url&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;atguigu.driver&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;atguigu.username&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;atguigu.password&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br></code></pre></td></tr></table></figure>
</li>
<li><p>XMLIoC方式问题总结</p>
<ol>
<li>注入的属性必须添加setter方法、代码结构乱！</li>
<li>配置文件和Java代码分离、编写不是很方便！</li>
<li>XML配置文件解析效率低</li>
</ol>
</li>
</ul>
<h2 id="2-基于-注解-方式管理Bean"><a href="#2-基于-注解-方式管理Bean" class="headerlink" title="2.基于 注解 方式管理Bean"></a>2.基于 注解 方式管理Bean</h2><h3 id="实验一：Bean注解标记和扫描"><a href="#实验一：Bean注解标记和扫描" class="headerlink" title="实验一：Bean注解标记和扫描"></a>实验一：Bean注解标记和扫描</h3><ol>
<li>类上添加IoC注解</li>
<li>在xml文件中,配置扫描包<br>（本质上：所有一切的操作都是 Java 代码来完成的，XML 和注解只是告诉框架中的 Java 代码如何执行。）</li>
</ol>
<p>@Controller、@Service、@Repository这三个注解只是在@Component注解的基础上起了三个新的名字。(使用IOC容器管理这些组件来说没有区别，也就是语法层面没有区别)</p>
<ul>
<li><p>普通配置扫描包<br>context:component-scan,指定扫描的包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    普通配置包扫描</span><br><span class="hljs-comment">base-packeage：指定ioc容器在哪些包下扫面，一个或者多个，用逗号隔开</span><br><span class="hljs-comment">指定包，包括子包的所有类</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.carrie.ioc01&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>指定排除组件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.atguigu.components&quot;</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- context:exclude-filter标签：指定排除规则 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- type属性：指定根据什么来进行排除，annotation取值表示根据注解来排除 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- expression属性：指定排除规则的表达式，对于注解来说指定全类名即可 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>指定包含组件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 仅扫描 = 关闭默认规则 + 追加规则 --&gt;</span><br><span class="hljs-comment">&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 （所有注解不生效）--&gt;</span><br><span class="hljs-comment">&lt;!-- component-scan表示都生效了，include-filter没用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.atguigu.ioc.components&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>指定组件BeanName(只设置一个属性时，value可以省略)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller(value = &quot;tianDog&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SoldierController</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li><strong>总结</strong></li>
</ol>
<ul>
<li>注解方式IoC只是标记哪些类要被Spring管理</li>
<li>最终，我们还需要XML方式或者后面讲解Java配置类方式<strong>指定注解生效的包</strong></li>
<li><strong>现阶段配置方式为 注解 （标记）+ XML（扫描）</strong></li>
</ul>
<h3 id="实验二：Bean作用域和周期方法"><a href="#实验二：Bean作用域和周期方法" class="headerlink" title="实验二：Bean作用域和周期方法"></a>实验二：Bean作用域和周期方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表</span><br>  <span class="hljs-meta">@PostConstruct</span>  <span class="hljs-comment">//注解制指定初始化方法</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 初始化逻辑</span><br>  &#125;<br>  <span class="hljs-meta">@PreDestroy</span> <span class="hljs-comment">//注解指定销毁方法</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanup</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 释放资源逻辑</span><br>  &#125;<br>  <span class="hljs-comment">//作用域</span><br>  <span class="hljs-meta">@Scope(scopeName = ConfigurableBeanFactory.SCOPE_SINGLETON)</span> <span class="hljs-comment">//单例,默认值</span><br>  <span class="hljs-meta">@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span> <span class="hljs-comment">//多例  二选一</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanOne</span> &#123;<br><br>    <span class="hljs-comment">//周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表</span><br>    <span class="hljs-meta">@PostConstruct</span>  <span class="hljs-comment">//注解制指定初始化方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// 初始化逻辑</span><br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>多例不会调用destroy方法！！</p>
<h3 id="实验三：Bean属性赋值，引用类型自动装配（DI）"><a href="#实验三：Bean属性赋值，引用类型自动装配（DI）" class="headerlink" title="实验三：Bean属性赋值，引用类型自动装配（DI）"></a>实验三：Bean属性赋值，引用类型自动装配（DI）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">//相当于&lt;property;自动装配注解（不需要提供set方法）</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<span class="hljs-comment">//接口可以接收值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//调用业务层show</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>@AutoWired可以加在成员变量，构造方法或set方法上</p>
<center><img src="(https://dzc2000919.oss-cn-shanghai.aliyuncs.com/zyx_images/202401291842927.png" width="50%" height="50%"></center>
- 和所需类型匹配的 bean 不止一个
    - 没有 @Qualifier 注解：根据 @Autowired 标记位置成员变量的变量名作为 bean 的 id 进行匹配
    - 使用 @Qualifier 注解：根据 @Qualifier 注解中指定的名称作为 bean 的id进行匹配

<ul>
<li>自动装配的对象，必须在ioc容器中，否则报错<br>佛系装配（不推荐）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 给@Autowired注解设置required = false属性表示：能装就装，装不上就不装</span><br> <span class="hljs-meta">@Autowired(required = false)</span><br></code></pre></td></tr></table></figure></li>
<li>同一个类型对应多个组件（默认根据<strong>成员变量名</strong>查找，不相同时不报错），也报错，需要指定类型名<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>   <span class="hljs-meta">@Qualifier(value = &quot;userServiceImpl&quot;)</span><br>   <span class="hljs-comment">// 根据面向接口编程思想，使用接口类型引入Service组件</span><br>   <span class="hljs-keyword">private</span> UserService userService;<br></code></pre></td></tr></table></figure>
优化（自动注入资源）：<br>@Autowired+  @Qualifier(value &#x3D; “userServiceImpl”)&#x3D;<strong>@Resource(name&#x3D;”userServiceImpl”)</strong></li>
</ul>
<p>该注解为java扩展资源，需要导入依赖(@Resource注解默认根据Bean名称装配，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型装配)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.annotation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="实验四：Bean属性赋值：基本类型属性赋值（DI）"><a href="#实验四：Bean属性赋值：基本类型属性赋值（DI）" class="headerlink" title="实验四：Bean属性赋值：基本类型属性赋值（DI）"></a>实验四：Bean属性赋值：基本类型属性赋值（DI）</h3><p><strong>@Value 通常用于注入外部化属性</strong><br>用于读取外部文件赋值，properties文件（记得需要用property-placehoder，引入到IoC容器）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 情况1: $&#123;key&#125; 取外部配置key对应的值!</span><br><span class="hljs-comment">    * 情况2: $&#123;key:defaultValue&#125; 没有key,可以给与默认值</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Value(&quot;$&#123;catalog:hahaha&#125;&quot;)</span><br>   <span class="hljs-keyword">private</span> String name;<br></code></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>注解+xml文件：第三方类必须在xml文件中配置，不能用注解的方式。</p>
<center><img src=https://dzc2000919.oss-cn-shanghai.aliyuncs.com/zyx_images/202401291920437.png) width="70%" height="70%"></center>

<h2 id="3-基于-配置类-方式管理Bean"><a href="#3-基于-配置类-方式管理Bean" class="headerlink" title="3.基于 配置类 方式管理Bean"></a>3.基于 配置类 方式管理Bean</h2><p>Spring <strong>完全注解配置</strong>（Fully Annotation-based Configuration）是指通过 Java配置类 代码来配置 Spring 应用程序，完全注解配置具有更强的类型安全性和更好的可读性。<br><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/zyx_images/202401291931804.png"></p>
<ul>
<li>配置类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.PropertySource;<br><br><span class="hljs-comment">//标注当前类是配置类，替代application.xml    </span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-comment">//使用注解读取外部配置，替代 &lt;context:property-placeholder标签</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:application.properties&quot;)</span><br><span class="hljs-comment">//使用@ComponentScan注解,可以配置扫描包,替代&lt;context:component-scan标签</span><br><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfiguration</span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
根据配置类创建IoC容器(有参构造函数)：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AnnotationConfigApplicationContext 根据配置类创建 IOC 容器对象</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">iocContainerAnnotation</span> <span class="hljs-operator">=</span> <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(MyConfiguration.class);<br></code></pre></td></tr></table></figure></li>
</ul>
<p>无参构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AnnotationConfigApplicationContext-IOC容器对象</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">iocContainerAnnotation</span> <span class="hljs-operator">=</span> <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>();<br><span class="hljs-comment">//外部设置配置类</span><br>iocContainerAnnotation.register(MyConfiguration.class);<br><span class="hljs-comment">//刷新后方可生效！！</span><br>iocContainerAnnotation.refresh();<br><br></code></pre></td></tr></table></figure>
<ul>
<li>总结：<br>@Configuration指定一个类为配置类，可以添加配置注解，替代配置xml文件<br>@ComponentScan(basePackages &#x3D; {“包”,”包”}) 替代&lt;context:component-scan标签实现注解扫描<br>@PropertySource(“classpath:配置文件地址”) 替代 &lt;context:property-placeholder标签<br>配合IoC&#x2F;DI注解，可以进行完整注解开发！</li>
</ul>
<h3 id="实验二：-Bean定义组件"><a href="#实验二：-Bean定义组件" class="headerlink" title="实验二：@Bean定义组件"></a>实验二：@Bean定义组件</h3><p><strong>场景需求</strong>：将Druid连接池对象存储到IoC容器<br><strong>需求分析</strong>：<strong>第三方jar包</strong>的类，添加到ioc容器，<strong>无法使用@Component等相关注解</strong>。（源码jar包内容为只读模式）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//标注当前类是配置类，替代application.xml    </span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-comment">//引入jdbc.properties文件</span><br><span class="hljs-meta">@PropertySource(&#123;&quot;classpath:application.properties&quot;,&quot;classpath:jdbc.properties&quot;&#125;)</span><br><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfiguration</span> &#123;<br><br>    <span class="hljs-comment">//如果第三方类进行IoC管理,无法直接使用@Component相关注解</span><br>    <span class="hljs-comment">//解决方案: xml方式可以使用&lt;bean标签</span><br>    <span class="hljs-comment">//解决方案: 配置类方式,可以使用方法返回值+@Bean注解（真正让配置类的方法创建的组件存储在ioc容器）</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    方法的形参值也可以写在成员变量处（全局用）</span><br><span class="hljs-comment">    方法返回值：bean的类型或者其接口或者父类</span><br><span class="hljs-comment">    方法的名字：bean的id</span><br><span class="hljs-comment">    方法体：自定义实现过程</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">CreateDataSource</span><span class="hljs-params">(<span class="hljs-meta">@Value(&quot;$&#123;jdbc.user&#125;&quot;)</span> String username,</span><br><span class="hljs-params">                                       <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span>String password,</span><br><span class="hljs-params">                                       <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span>String url,</span><br><span class="hljs-params">                                       <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span>String driverClassName)</span>&#123;<br>        <span class="hljs-comment">//使用Java代码实例化</span><br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        dataSource.setUsername(username);<br>        dataSource.setPassword(password);<br>        dataSource.setUrl(url);<br>        dataSource.setDriverClassName(driverClassName);<br>        <span class="hljs-comment">//返回结果即可</span><br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="实验三：高级特性：-Bean注解细节"><a href="#实验三：高级特性：-Bean注解细节" class="headerlink" title="实验三：高级特性：@Bean注解细节"></a>实验三：高级特性：@Bean注解细节</h3><ol>
<li>beanName（默认方法名）：指定<strong>name&#x2F;value</strong>属性取名字。</li>
<li>周期方法：</li>
</ol>
<ul>
<li>原有注解方案：PostConstrust+PreDestroy注解指定</li>
<li>bean的属性指定：<strong>initMethod&#x2F;destroyMethod</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanOne</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// initialization logic</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanTwo</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanup</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// destruction logic</span><br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>  <span class="hljs-meta">@Bean(initMethod = &quot;init&quot;)</span><br>  <span class="hljs-keyword">public</span> BeanOne <span class="hljs-title function_">beanOne</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanOne</span>();<br>  &#125;<br><br>  <span class="hljs-meta">@Bean(destroyMethod = &quot;cleanup&quot;)</span><br>  <span class="hljs-keyword">public</span> BeanTwo <span class="hljs-title function_">beanTwo</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanTwo</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>作用域：**@Scope(scopeName&#x3D;ConfigurableBeanFactory.xxxxxx)**</li>
<li>参数引用：方法参数传递 Bean 实例的引用（如果其他组件也是@Bean方法，可以直接调用，从IoC容器获取组件）<br>如果有多个同类型bean，可以让形参名称等于对应的beanId标识</li>
</ol>
<h3 id="实验四：高级特性：-Import扩展"><a href="#实验四：高级特性：-Import扩展" class="headerlink" title="实验四：高级特性：@Import扩展"></a>实验四：高级特性：@Import扩展</h3><p><strong>@Import 注释允许从另一个配置类加载 @Bean 定义</strong><br>实例化时不需要同时指定 ConfigA.class 和 ConfigB.class,只需显式提供 ConfigB.class(B配置类中import了A)</p>
<p>总结（<strong>完全注解方式（配置类+注解）是现在主流配置方式</strong>）：<br><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/zyx_images/202401292147927.png"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h3 id="XML方式配置总结"><a href="#XML方式配置总结" class="headerlink" title="XML方式配置总结"></a>XML方式配置总结</h3><ol>
<li>所有内容写到xml格式配置文件中</li>
<li>声明bean通过&lt;bean标签</li>
<li>&lt;bean标签包含基本信息（id,class）和属性信息 &lt;property name value &#x2F; ref</li>
<li>引入外部的properties文件可以通过&lt;context:property-placeholder</li>
<li>IoC具体容器实现选择ClassPathXmlApplicationContext对象</li>
</ol>
<h3 id="XML-注解方式配置总结"><a href="#XML-注解方式配置总结" class="headerlink" title="XML+注解方式配置总结"></a>XML+注解方式配置总结</h3><ol>
<li>注解负责标记IoC的类和进行属性装配</li>
<li>xml文件依然需要，需要通过&lt;context:component-scan标签指定注解范围</li>
<li>标记IoC注解：@Component,@Service,@Controller,@Repository </li>
<li>标记DI注解：@Autowired @Qualifier @Resource @Value</li>
<li>IoC具体容器实现选择ClassPathXmlApplicationContext对象</li>
</ol>
<h3 id="完全注解方式配置总结"><a href="#完全注解方式配置总结" class="headerlink" title="完全注解方式配置总结"></a>完全注解方式配置总结</h3><ol>
<li>完全注解方式指的是去掉xml文件，使用配置类 + 注解实现</li>
<li>xml文件替换成使用@Configuration注解标记的类</li>
<li>标记IoC注解：@Component,@Service,@Controller,@Repository </li>
<li>标记DI注解：@Autowired @Qualifier @Resource @Value</li>
<li>&lt;context:component-scan标签指定注解范围使用@ComponentScan(basePackages &#x3D; {“com.atguigu.components”})替代</li>
<li>&lt;context:property-placeholder引入外部配置文件使用@PropertySource({“classpath:application.properties”,”classpath:jdbc.properties”})替代</li>
<li>&lt;bean 标签使用@Bean注解和方法实现</li>
<li>IoC具体容器实现选择AnnotationConfigApplicationContext对象</li>
</ol>
<h2 id="整合测试环境"><a href="#整合测试环境" class="headerlink" title="整合测试环境"></a>整合测试环境</h2><p>1.不需要自己创建IOC容器对象了<br>2.任何需要的bean都可以在测试类中直接享受自动装配</p>
<p>导入相关依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--junit5测试--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>整合测试注解</strong>使用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@SpringJUnitConfig(locations = &#123;&quot;classpath:spring-context.xml&quot;&#125;)  //指定配置文件xml</span><br><span class="hljs-meta">@SpringJUnitConfig(value = &#123;BeanConfig.class&#125;)</span>  <span class="hljs-comment">//指定配置类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Junit5IntegrationTest</span> &#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> User user;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testJunit5</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="三、Spring-AOP面向切面编程"><a href="#三、Spring-AOP面向切面编程" class="headerlink" title="三、Spring AOP面向切面编程"></a>三、Spring AOP面向切面编程</h1><p>存在问题：附加功能代码重复，分散在各个业务功能方法中，冗余。<br>核心就是：<strong>解耦</strong>，把附加功能从业务功能代码中抽取出来。<br>将重复的代码统一提取，并且[[动态插入]]到每个业务方法！</p>
<h2 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1.代理模式"></a>1.代理模式</h2><p>提供一个代理类，在调用目标方法的时候，不直接对目标方法进行调用，通过代理类间接调用。</p>
<center><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/zyx_images/202401301546980.png" width="70%" height="70%"></center>

<p><strong>代理</strong>：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法<br><strong>目标</strong>：被代理“套用”了核心逻辑代码的类、对象、方法</p>
<ul>
<li><p>静态代理<br>实现类和代理类实现同一个接口，在代理类中调用目标（实现类）的核心方法，然后加上非核心逻辑<br>存在问题：静态代理确实实现了解耦，代码都写死了，不具备任何的灵活性。eg:日志功能，其他地方也需要附加日志，还需要声明更多个静态代理类，产生了大量重复的代码，日志功能是分散的，没有统一管理。<br>进一步的需求：将日志功能集中到一个代理类中，有其他日志需求，都通过这一个代理类来实现（动态代理技术）</p>
</li>
<li><p>动态代理技术</p>
</li>
</ul>
<ol>
<li>JDK动态代理：<strong>JDK原生</strong>的实现方式，需要被代理的目标类必须实现接口（根据目标类的接口动态生成一个代理对象，<strong>代理对象和目标对象有相同的接口</strong>）。</li>
<li>cglib（在Spring包中）：通过<strong>继承被代理的目标类</strong>实现代理，所以不需要目标类实现接口。</li>
</ol>
<p>总结：<strong>代理方式可以解决附加功能代码干扰核心代码和不方便统一维护的问题！</strong>，无论使用静态代理和动态代理(jdk,cglib)，程序员的工作都比较繁琐，需要自己编写代理工厂等！</p>
<p><strong>Spring AOP框架</strong>是对动态代理的简化。</p>
<h2 id="2-Spring-AOP框架介绍"><a href="#2-Spring-AOP框架介绍" class="headerlink" title="2.Spring AOP框架介绍"></a>2.Spring AOP框架介绍</h2><ul>
<li>AOP：Aspect Oriented Programming面向切面编程（<strong>横向的编程思维</strong>）</li>
<li>AOP可以说是OOP（Object Oriented Programming，面向对象编程）的<strong>补充和完善</strong></li>
<li><strong>将代码中重复的非核心业务提取到一个公共模块，然后利用动态代理技术，横向的插入到各个方法中。解决非核心代码冗余的问题。</strong></li>
</ul>
<p>优势：OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于<strong>模拟公共行为</strong>的一个集合（完全使用、重写、局部修改父类方法）<br>不足：OOP允许开发者定义<strong>纵向</strong>的关系，但并<strong>不适合定义横向的关系</strong>，例如日志功能</p>
<ul>
<li><p>AOP主要的应用场景<br>日志记录、事务处理、安全控制、性能监控、异常处理、缓存控制、动态代理</p>
</li>
<li><p>术语</p>
</li>
</ul>
<ol>
<li><strong>横切关注点</strong><br>AOP把软件系统分为两个部分：核心关注点和横切关注点。<br>业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点（发生在核心关注点的多处，而各处基本相似）。</li>
<li><strong>通知（增强）</strong>‘<br>每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。<br>前置通知：在被代理的目标方法前执行；<br>返回通知：在被代理的目标方法成功结束后执行；<br>异常通知：在被代理的目标方法异常结束后执行；<br>后置通知：在被代理的目标方法最终结束后执行；<br>环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</li>
<li><strong>连接点 joinpoint</strong><br>在 Spring 中，可以被动态代理拦截目标类的方法</li>
<li><strong>切入点pointcut</strong><br>定位连接点的方式（被选中的连接点）</li>
<li><strong>切面aspect</strong><br>切入点和通知的结合，是一个类</li>
<li><strong>目标target</strong><br>被代理的目标对象。</li>
<li><strong>代理proxy</strong><br>向目标对象应用通知之后创建的代理对象</li>
<li><strong>织入weave</strong><br>生成代理对象的过程。可以在编译期织入，也可以<strong>在运行期织入</strong>，Spring采用后者</li>
</ol>
<center><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/zyx_images/202401301658435.png" width="70%" height="70%"></center>

<ul>
<li>梳理</li>
</ul>
<ol>
<li>AOP一种区别于OOP的编程思维，用来完善和解决OOP的非核心代码冗余和不方便统一维护问题。</li>
<li>代理技术（动态代理|静态代理）是实现<strong>AOP思维编程</strong>的具体技术，但是自己使用动态代理实现代码比较繁琐。</li>
<li><strong>Spring AOP框架</strong>，基于AOP编程思维，<strong>封装动态代理技术</strong>，简化动态代理技术实现的框架。SpringAOP内部帮助我们实现动态代理，我们只需写少量的配置，指定生效范围即可,即可完成面向切面思维编程的实现。</li>
</ol>
<h2 id="3-Spring-AOP基于注解方法实现和细节"><a href="#3-Spring-AOP基于注解方法实现和细节" class="headerlink" title="3.Spring AOP基于注解方法实现和细节"></a>3.Spring AOP基于注解方法实现和细节</h2><h3 id="1-初步实现"><a href="#1-初步实现" class="headerlink" title="(1)初步实现"></a>(1)初步实现</h3><center><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/zyx_images/202401301704793.png" width="70%" height="70%"></center>

<p>只需要导入<strong>spring-context</strong>（依赖传递spring-aop）和<strong>spring-aspects</strong>（传递aspectj）</p>
<center><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/zyx_images/202401301722335.png" width="70%" height="70%"></center>
aop只针对ioc容器的对象->创建代理对象->将代理对象存储在ioc容器中

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.carrie.config.JavaConfig;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit.jupiter.SpringJUnitConfig;<br><span class="hljs-keyword">import</span> com.carrie.service.Calculator;<br><br><span class="hljs-meta">@SpringJUnitConfig(value = JavaConfig.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAopTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Calculator calculator;<span class="hljs-comment">//用接口取值，否则得到的是动态代理的实现类</span><br>    <span class="hljs-comment">//aop,代理，jdk，接口，代理类，代理对象和实现类是平级的关系不能接收值,必须用接口接收值</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> calculator.add(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        System.out.println(<span class="hljs-string">&quot;result=&quot;</span>+result);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.carrie&quot;)</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><span class="hljs-comment">//开启aspectj注解!!!!</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在xml文件中，开启aspectj注解</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 开启aspectj框架注解支持--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.carrie.advice;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.After;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">增强类中存储增强代码：</span><br><span class="hljs-comment">根据插入的位置决定定义几个方法；</span><br><span class="hljs-comment">使用注解配置。前置@Before，后置@AfterReturning，异常@AfterThrowing，最后@After和环绕@Around</span><br><span class="hljs-comment">配置切点表达式</span><br><span class="hljs-comment">加入ioc容器，配置aspect</span><br><span class="hljs-comment">开启aspect注解的支持</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAdvice</span> &#123;<br>    <span class="hljs-meta">@Before(value = &quot;execution(* com.carrie.service.Impl.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;方法开始了&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@After(value = &quot;execution(* com.carrie.service.Impl.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;方法结束了&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@AfterThrowing(value = &quot;execution(* com.carrie.service.Impl.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">error</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;方法报错了&quot;</span>);<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-获取通知细节信息"><a href="#2-获取通知细节信息" class="headerlink" title="(2)获取通知细节信息"></a>(2)获取通知细节信息</h3><ul>
<li><strong>JointPoint接口</strong><br>需要获取方法签名、传入的实参等信息时，可以在通知方法声明JoinPoint类型的形参。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">定义四个增强方法，获取目标方法的信息（方法名，参数，访问修饰符，所属的类信息）</span><br><span class="hljs-comment">返回的结果：@AfterReturning(在注解中，用retruning指定接受的形参名字)（方法中加Object reslut）</span><br><span class="hljs-comment">异常信息：@AfterThrowing(在注解中，用Throwing指定接受的形参名字)（方法中加Throwable e）</span><br><span class="hljs-comment">TODO：JoinPoint包含目标方法的信息</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdvice</span> &#123;<br><br>    <span class="hljs-meta">@Before(value = &quot;execution(* com.carrie.service.Impl.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;<br>        <span class="hljs-comment">//获取方法属于类的信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">simpleName</span> <span class="hljs-operator">=</span> joinPoint.getTarget().getClass().getSimpleName();<br>        <span class="hljs-comment">//获取访问修饰符</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getModifiers();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Modifier.toString(modifiers);<br>        <span class="hljs-comment">//获取方法名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();<br>        <span class="hljs-comment">//获取参数列表</span><br>        Object[] args = joinPoint.getArgs();<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-切点表达式语法"><a href="#3-切点表达式语法" class="headerlink" title="(3)切点表达式语法"></a>(3)切点表达式语法</h3><p><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/zyx_images/202402031436612.png"></p>
<ul>
<li>切点表达式的重用复用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//提取切点注解使用@Pointcut(切点表达式) ， 需要添加到一个无参数无返回值方法上即可！</span><br><span class="hljs-meta">@Pointcut(&quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int)))</span><span class="hljs-string">&quot;)</span><br><span class="hljs-string">public void declarPointCut() &#123;&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">@Before(value = &quot;</span>declarPointCut()<span class="hljs-string">&quot;)</span><br><span class="hljs-string">public void printLogBeforeCoreOperation(JoinPoint joinPoint) &#123;&#125;</span><br></code></pre></td></tr></table></figure></li>
<li>不同类中引用<br>不同类在引用切点，需要添加类的全限定符+方法名.</li>
<li><strong>将切点表达式统一存储到一个类中进行集中管理和维护</strong></li>
</ul>
<h3 id="4-环绕通知及切面优先级设置"><a href="#4-环绕通知及切面优先级设置" class="headerlink" title="(4)环绕通知及切面优先级设置"></a>(4)环绕通知及切面优先级设置</h3><p>环绕通知对应整个 try…catch…finally 结构，<strong>包括前面四种通知的所有功能</strong>。<br>环绕通知需要定义目标方法的执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用@Around注解标明环绕通知方法</span><br><span class="hljs-meta">@Around(value = &quot;com.atguigu.aop.aspect.AtguiguPointCut.transactionPointCut()&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">manageTransaction</span><span class="hljs-params">(</span><br><span class="hljs-params">    </span><br><span class="hljs-params">        // 通过在通知方法形参位置声明ProceedingJoinPoint类型的形参，</span><br><span class="hljs-params">        // Spring会将这个类型的对象传给我们</span><br><span class="hljs-params">        ProceedingJoinPoint joinPoint)</span> &#123;<br>    <br>    <span class="hljs-comment">// 通过ProceedingJoinPoint对象获取外界调用目标方法时传入的实参数组</span><br>    Object[] args = joinPoint.getArgs();<br>    <br>    <span class="hljs-comment">// 通过ProceedingJoinPoint对象获取目标方法的签名对象</span><br>    <span class="hljs-type">Signature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> joinPoint.getSignature();<br>    <br>    <span class="hljs-comment">// 通过签名对象获取目标方法的方法名</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> signature.getName();<br>    <br>    <span class="hljs-comment">// 声明变量用来存储目标方法的返回值</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">targetMethodReturnValue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>    <br>        <span class="hljs-comment">// 在目标方法执行前：开启事务（模拟）</span><br>        log.debug(<span class="hljs-string">&quot;[AOP 环绕通知] 开启事务，方法名：&quot;</span> + methodName + <span class="hljs-string">&quot;，参数列表：&quot;</span> + Arrays.asList(args));<br>    <br>        <span class="hljs-comment">// 过ProceedingJoinPoint对象调用目标方法</span><br>        <span class="hljs-comment">// 目标方法的返回值一定要返回给外界调用者</span><br>        targetMethodReturnValue = joinPoint.proceed(args);<br>    <br>        <span class="hljs-comment">// 在目标方法成功返回后：提交事务（模拟）</span><br>        log.debug(<span class="hljs-string">&quot;[AOP 环绕通知] 提交事务，方法名：&quot;</span> + methodName + <span class="hljs-string">&quot;，方法返回值：&quot;</span> + targetMethodReturnValue);<br>    <br>    &#125;<span class="hljs-keyword">catch</span> (Throwable e)&#123;<br>    <br>        <span class="hljs-comment">// 在目标方法抛异常后：回滚事务（模拟）</span><br>        log.debug(<span class="hljs-string">&quot;[AOP 环绕通知] 回滚事务，方法名：&quot;</span> + methodName + <span class="hljs-string">&quot;，异常：&quot;</span> + e.getClass().getName());<br>    <br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>    <br>        <span class="hljs-comment">// 在目标方法最终结束后：释放数据库连接</span><br>        log.debug(<span class="hljs-string">&quot;[AOP 环绕通知] 释放数据库连接，方法名：&quot;</span> + methodName);<br>    <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> targetMethodReturnValue;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>@Order(较小的数)：优先级高</p>
<center><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/zyx_images/202402032004287.png" width="50%" height="50%"></center>

<h2 id="4-Spring-AOP基于XML方法实现（了解）"><a href="#4-Spring-AOP基于XML方法实现（了解）" class="headerlink" title="4.Spring AOP基于XML方法实现（了解）"></a>4.Spring AOP基于XML方法实现（了解）</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置目标类的bean --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;calculatorPure&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.aop.imp.CalculatorPureImpl&quot;</span>/&gt;</span><br>    <br><span class="hljs-comment">&lt;!-- 配置切面类的bean --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;logAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.aop.aspect.LogAspect&quot;</span>/&gt;</span><br>    <br><span class="hljs-comment">&lt;!-- 配置AOP --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 配置切入点表达式 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;logPointCut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* *..*.*(..))&quot;</span>/&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- aop:aspect标签：配置切面 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- ref属性：关联切面类的bean --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;logAspect&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- aop:before标签：配置前置通知 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- method属性：指定前置通知的方法名 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- pointcut-ref属性：引用切入点表达式 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;printLogBeforeCore&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;logPointCut&quot;</span>/&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!-- aop:after-returning标签：配置返回通知 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- returning属性：指定通知方法中用来接收目标方法返回值的参数名 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-returning</span></span><br><span class="hljs-tag">                <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;printLogAfterCoreSuccess&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;logPointCut&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">returning</span>=<span class="hljs-string">&quot;targetMethodReturnValue&quot;</span>/&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!-- aop:after-throwing标签：配置异常通知 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- throwing属性：指定通知方法中用来接收目标方法抛出异常的异常对象的参数名 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-throwing</span></span><br><span class="hljs-tag">                <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;printLogAfterCoreException&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;logPointCut&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">throwing</span>=<span class="hljs-string">&quot;targetMethodException&quot;</span>/&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!-- aop:after标签：配置后置通知 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;printLogCoreFinallyEnd&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;logPointCut&quot;</span>/&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!-- aop:around标签：配置环绕通知 --&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;aop:around method=&quot;……&quot; pointcut-ref=&quot;logPointCut&quot;/&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><br></code></pre></td></tr></table></figure>
<h2 id="5-Spring-AOP对获取Bean的影响理解"><a href="#5-Spring-AOP对获取Bean的影响理解" class="headerlink" title="5.Spring AOP对获取Bean的影响理解"></a>5.Spring AOP对获取Bean的影响理解</h2><h1 id="四、声明式事务"><a href="#四、声明式事务" class="headerlink" title="四、声明式事务"></a>四、声明式事务</h1><p>编程式事务：使用try……catch手动编写，进行事务的开启提交和回滚。（出现大量的冗余）<br>声明式事务（spring-tx框架，是对aop进一步封装）：是指使用注解或 XML 配置的方式来控制事务的提交和回滚。</p>
<p>@Transactional 可以加在方法上或者类上</p>
<p>配置类上需要加：@EnableTransactionManagement()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//事务</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> TransactionManager <span class="hljs-title function_">transactionManager</span><span class="hljs-params">(DataSource dataSource)</span>&#123;<br>    <span class="hljs-type">DataSourceTransactionManager</span> <span class="hljs-variable">dataSourceTransactionManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceTransactionManager</span>();<br>    <span class="hljs-comment">//需要连接池对象</span><br>    dataSourceTransactionManager.setDataSource(dataSource);<br>    <span class="hljs-keyword">return</span> dataSourceTransactionManager;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h2><p><strong>方法上的注解会覆盖类上的注解</strong></p>
<h3 id="只读"><a href="#只读" class="headerlink" title="只读"></a>只读</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// readOnly = true把当前事务设置为只读 默认是false!</span><br><span class="hljs-meta">@Transactional(readOnly = true)</span><br></code></pre></td></tr></table></figure>
<p>可以直接加在类上</p>
<h3 id="超出时间"><a href="#超出时间" class="headerlink" title="超出时间"></a>超出时间</h3><p>超时回滚，释放异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Transactional(readOnly = false,timeout = 3)</span><br></code></pre></td></tr></table></figure>

<h3 id="事务异常"><a href="#事务异常" class="headerlink" title="事务异常"></a>事务异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class)</span><span class="hljs-comment">//设置哪些异常回滚</span><br><span class="hljs-comment">//noRollbackFor = FileNotFoundException.class：设置的回滚异常范围内，某些异常不回滚</span><br></code></pre></td></tr></table></figure>

<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ol>
<li>读未提交（Read Uncommitted）：事务可以读取未被提交的数据，容易产生脏读、不可重复读和幻读等问题。</li>
<li>读已提交（Read Committed）：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读。</li>
<li>可重复读（Repeatable Read）：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改。可以避免脏读和不可重复读，但仍有幻读的问题。</li>
<li>串行化（Serializable）：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景。</li>
</ol>
<p>推荐使用第二种隔离级别：读已提交<br><code> isolation = Isolation.REPEATABLE_READ)</code></p>
<h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p>父方法中调用多个方法，子方法定义了事务，父方法事务，之间的传播行为。<br>传播行为是面试题，一般使用默认值REQUIRED。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED <br>默认值</td>
<td>如果父方法有事务，就加入，如果没有就新建自己独立</td>
</tr>
<tr>
<td>REQUIRES_NEW</td>
<td>不管父方法是否有事务，我都新建事务，都是独立的</td>
</tr>
</tbody></table>
<ul>
<li>注意：<br>在同一个类中，对于@Transactional注解的方法调用，事务传播行为不会生效。Spring框架中使用代理模式实现了事务机制，<strong>在同一个类中的方法调用并不经过代理</strong>，而是通过对象的方法调用，因此@Transactional注解的设置不会被代理捕获，也就不会产生任何事务传播行为的效果。</li>
</ul>
<h1 id="Spring总结"><a href="#Spring总结" class="headerlink" title="Spring总结"></a>Spring总结</h1><p><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/zyx_images/202402221724447.png"></p>

      </div>
    </div>
  </article>
  <div class="post__foot">
    
    <div class="post-nav">
  
    <a class="post-nav-item-left" href="/2024/02/22/Mybatis/">
      <div class="text-align">
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596"/>
        </svg>
        <span class="text-small">上一篇</span>
      </div>
      <div>Mybatis</div>
    </a>
  
  <div class="vhr"></div>
  
    <a class="post-nav-item-right" href="/2024/01/18/Maven/">
      <div class="text-align">
        <span class="text-small">下一篇</span>
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             transform="scale(-1,-1)"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596"/>
        </svg>
      </div>
      Maven
    </a>
  
</div>

    
      <div class="related-post">
  <div class="related__head">
  <a href="/tags/Java/" class="post-tag">#Java</a><a href="/tags/%E5%BC%80%E5%8F%91/" class="post-tag">#开发</a><a href="/tags/SSM/" class="post-tag">#SSM</a>

</div>
  <div class="realated__body">
    
      DEBUG: 请安装插件 <a target="_blank" rel="noopener" href="https://github.com/tea3/hexo-related-popular-posts">hexo-related-popular-posts</a> 或关闭 related_post 配置!
    
  </div>
</div>

    
    
  </div>

    </div>
    <div class="foot">
      <div class="foot-inner">
        <div class="foot__head">
          
            <div class="foot-line">
              
                <div class="matts">若</div>
              
                <div class="matts">无</div>
              
                <div class="matts">闲</div>
              
                <div class="matts">事</div>
              
                <div class="matts">挂</div>
              
                <div class="matts">心</div>
              
                <div class="matts">头</div>
              
            </div>
          
            <div class="foot-line">
              
                <div class="matts">便</div>
              
                <div class="matts">是</div>
              
                <div class="matts">人</div>
              
                <div class="matts">间</div>
              
                <div class="matts">好</div>
              
                <div class="matts">时</div>
              
                <div class="matts">节</div>
              
            </div>
          
        </div>
        <div class="foot__body">
          
            <div class="foot-item">
              <div class="foot-item__head">朋友</div>
              <div class="foot-item__body">
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/icon/icon-link.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://carriemint.github.io">芋圆的主页</a>
                  </div>
                
                <div class="text">
                  <img alt="link" height="20px" width="20px" src="/images/icon/icon-link+.svg"/>
                  <a class="foot-link"
                     href="mailto:863162796@qq.com?subject=%E7%94%B3%E8%AF%B7%20Hozen.site%20%E7%9A%84%E5%8F%8B%E9%93%BE%E4%BD%8D%E7%BD%AE">
                  申请友链</a>
                </div>
              </div>
            </div>
          
          
            <div class="foot-item">
              <div class="foot-item__head">账号</div>
              <div class="foot-item__body">
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/logo-github.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://github.com/carriemint">carriemint</a>
                  </div>
                
              </div>
            </div>
          
          <div class="foot-item">
            <div class="foot-item__head">联系</div>
            <div class="foot-item__body">
              <div class="text">
                <img alt="link" height="20px" width="20px" src="/images/icon/icon-email.svg"/>
                <a class="foot-link" href="mailto:863162796@qq.com">863162796@qq.com</a>
              </div>
            </div>
          </div>
        </div>
        <div class="copyright">
          <a href="http://example.com">芋圆明天不困</a> &nbsp;|&nbsp;由&nbsp;<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>&nbsp;及&nbsp;
          <svg width="20" height="20" viewBox="0 0 725 725">
            <path fill-rule="evenodd" fill="rgb(221, 221, 221)" d="M145.870,236.632 L396.955,103.578 L431.292,419.44 L156.600,522.53 L145.870,236.632 Z"/>
            <path fill-rule="evenodd" fill="rgb(159, 159, 159)" d="M396.955,103.578 L564.345,234.486 L611.558,513.469 L431.292,419.44 L396.955,103.578 Z"/>
            <path fill-rule="evenodd" fill="rgb(0, 0, 0)" d="M431.292,419.44 L611.558,513.469 L358.327,595.18 L156.600,522.53 L431.292,419.44 Z"/>
          </svg>
          <a target="_blank" rel="noopener" href="https://github.com/hooozen/hexo-theme-tranquility">致远</a>&nbsp;驱动
        </div>
      </div>
    </div>
    
    
  

  </body>
</html>