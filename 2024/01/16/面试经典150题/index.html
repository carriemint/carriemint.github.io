<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf8"/>
    <meta name="viewport" content="initial-scale=1.0, width=device-width"/>
    <title>
      
        面试经典150题 | 芋圆明天不困
      
    </title>
    <meta name="description" content=""/>
    <meta name="keywords" content=""/>
    
      <link rel="apple-touch-icon"
            sizes="180x180"
            href="/images/apple-touch-icon.png"/>
    
    
      <link rel="icon"
            type="image/png"
            sizes="32x32"
            href="/images/favicon-32x32.png"/>
    
    
      <link rel="icon"
            type="image/png"
            sizes="16x16"
            href="/images/favicon-16x16.png"/>
    
    
      <link rel="mask-icon"
            href="/images/logo.svg"
            color=""/>
    
    
    
      
  <style>
    @font-face {
        font-family:sourceHanSerif;
        src: url(/font/regular.ttf);
        font-weight: regular;
    }
  </style>

  <style>
    @font-face {
        font-family:sourceHanSerif;
        src: url(/font/bold.ttf);
        font-weight: bold;
    }
  </style>


    
    <link rel="stylesheet"
          type="text/css"
          href='/css/layout.css'/>
    
    
  <link rel="stylesheet" type="text/css" href="/css/post.css" />
  

  <meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div class="head">
      <div class="nav">
        <a href='/' class="nav-logo">
          <img alt="logo" height="60px" width="60px" src="/images/logo.svg"/>
        </a>
        <input id="navBtn" type="checkbox"/>
        <div class="nav-menu">
          
            
              <a class="nav-menu-item" href="/CS">技术</a>
            
              <a class="nav-menu-item" href="/Others">杂七杂八</a>
            
          
          
        </div>
        <label class="nav-btn" for="navBtn"></label>
      </div>
    </div>
    <div class="body">
      
  <article class="post-content">
    <div class="post-inner--toc">
      <div class="post-content__head">
        <div class="post-title">面试经典150题</div>
        <div class="post-info">
          
  <a href="/tags/LeetCode/" class="post-tag">#LeetCode</a><a href="/tags/%E6%95%B0%E7%BB%84/" class="post-tag">#数组</a>


          <span class="post-date">2024-01-16</span>
        </div>
      </div>
      
        <aside class="toc-outer">
          <div class="toc-title">目录</div>
          <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="post-toc-text">88.合并两个有序数组</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#27-%E7%A7%BB%E5%87%BA%E5%85%83%E7%B4%A0"><span class="post-toc-text">27.移出元素</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="post-toc-text">26.删除有序数组中的重复项</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#80-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B92"><span class="post-toc-text">80.删除有序数组中的重复项2</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="post-toc-text">169. 多数元素</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#HashMap%E5%9F%BA%E7%A1%80%E7%89%88"><span class="post-toc-text">HashMap基础版</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E2%80%A6%E8%BF%9B%E9%98%B6%E7%89%88%EF%BC%88Boyer-Moore-%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95%EF%BC%89"><span class="post-toc-text">…进阶版（Boyer-Moore 投票算法）</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="post-toc-text">189.轮转数组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E2%80%A6%E6%B3%951%E4%BD%BF%E7%94%A8%E9%A2%9D%E5%A4%96%E6%95%B0%E7%BB%84"><span class="post-toc-text">…法1使用额外数组</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E2%80%A6%E6%B3%952%E7%8E%AF%E5%BD%A2%E6%9B%BF%E6%8D%A2"><span class="post-toc-text">…法2环形替换</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E2%80%A6%E6%B3%953%E7%BF%BB%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="post-toc-text">…法3翻转数组</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E9%97%B4"><span class="post-toc-text">121.买卖股票的最佳时间</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E9%97%B42"><span class="post-toc-text">122.买卖股票的最佳时间2</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="post-toc-text">55.跳跃游戏</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F2"><span class="post-toc-text">45.跳跃游戏2</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#274-H%E6%8C%87%E6%95%B0"><span class="post-toc-text">274.H指数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B3%951-%E6%8E%92%E5%BA%8F"><span class="post-toc-text">..法1:排序</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B3%95%E4%BA%8C%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="post-toc-text">..法二计数排序</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B3%95%E4%B8%89%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="post-toc-text">..法三二分查找</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#380-O-1-%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0"><span class="post-toc-text">380.O(1)时间插入、删除和获取随机元素</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#283-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="post-toc-text">283.除自身以外数组的乘积</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B3%951%E5%B7%A6%E5%8F%B3%E4%B9%98%E7%A7%AF%E5%88%97%E8%A1%A8"><span class="post-toc-text">..法1左右乘积列表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B3%95%E4%BA%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-1"><span class="post-toc-text">..法二空间复杂度O(1)</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#134-%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="post-toc-text">134.加油站</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C%EF%BC%88%E9%9A%BE%EF%BC%89"><span class="post-toc-text">135.分发糖果（难）</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="post-toc-text">42.接雨水</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B3%951%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="post-toc-text">..法1动态规划</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B3%952%E5%8D%95%E8%B0%83%E6%A0%88"><span class="post-toc-text">..法2单调栈</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B3%953%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="post-toc-text">..法3双指针（重要）</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0"><span class="post-toc-text">13.罗马数字转整数</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97"><span class="post-toc-text">12.整数转罗马数字</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="post-toc-text">58.最后一个单词的长度</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="post-toc-text">14.最长公共前缀</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="post-toc-text">151.反转字符串中的单词</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#6-Z%E5%AD%90%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="post-toc-text">6.Z子形变换</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E7%9A%84%E4%B8%8B%E6%A0%87"><span class="post-toc-text">28.找出字符串中第一个匹配的下标</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#68-%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90"><span class="post-toc-text">68.文本左右对齐</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="post-toc-text">125.验证回文串</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="post-toc-text">392.判断子序列</span></a></li></ol>
          <a href="#" class="toc-top">回到顶部</a>
        </aside>
      
      <div class="post-content__body">
        
          <div class="post-gallery">
            
          </div>
        
        <h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88.合并两个有序数组"></a>88.合并两个有序数组</h1><p>双指针<br>由于数组是增序，从数组末尾遍历更好</p>
<figure class="highlight plaintext"><figcaption><span>Solution &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">        int index1=m-1;</span><br><span class="line">        int index2=n-1;</span><br><span class="line">        int p;</span><br><span class="line">        for(p=m+n-1;p&gt;=0;p--)&#123;</span><br><span class="line">            if(index1&lt;0 ||index2&lt;0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(nums1[index1]&gt;nums2[index2])&#123;</span><br><span class="line">                nums1[p]=nums1[index1];</span><br><span class="line">                index1--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                nums1[p]=nums2[index2];</span><br><span class="line">                index2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //注意，可能有数组没有插入完全(num2更长，num1更长不用管因为是有序的)</span><br><span class="line">        if(index1&lt;0)&#123;</span><br><span class="line">            while(index2&gt;=0)&#123;</span><br><span class="line">                nums1[p]=nums2[index2];</span><br><span class="line">                p--;index2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="27-移出元素"><a href="#27-移出元素" class="headerlink" title="27.移出元素"></a>27.移出元素</h1><p>双指针，左右两边，将相同的元素，放在数组右边<br>仅仅只有left值不为val，才增。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">        int left=0;</span><br><span class="line">        int right=nums.length;</span><br><span class="line">        while(left&lt;right)&#123;</span><br><span class="line">            if(nums[left]==val)&#123;</span><br><span class="line">                nums[left]=nums[right-1];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a>26.删除有序数组中的重复项</h1><p>快指针和慢指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        int left=0,right=1;</span><br><span class="line">        while(right&lt;nums.length)&#123;</span><br><span class="line">            if(nums[left]!=nums[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">                nums[left]=nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        return left+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="80-删除有序数组中的重复项2"><a href="#80-删除有序数组中的重复项2" class="headerlink" title="80.删除有序数组中的重复项2"></a>80.删除有序数组中的重复项2</h1><p>只要保证不会有3个连续大小的即可，让slow-2与fast不相等的时候，赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        //注意排除特殊情况</span><br><span class="line">        if(nums.length&lt;=2)&#123;</span><br><span class="line">            return nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        int fast=2,slow=2;</span><br><span class="line">        while(fast&lt;nums.length)&#123;</span><br><span class="line">            if(nums[fast]!=nums[slow-2])&#123;</span><br><span class="line">                nums[slow]=nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">             fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h1><h2 id="HashMap基础版"><a href="#HashMap基础版" class="headerlink" title="HashMap基础版"></a>HashMap基础版</h2><p>使用hashmap存储计算每个元素的个数，然后遍历获取大多数元素值，时间空间复杂度均为O（n）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int majorityElement(int[] nums) &#123;</span><br><span class="line">        int count=nums.length/2;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hm=new HashMap();</span><br><span class="line">        for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            if(!hm.containsKey(nums[i]))&#123;</span><br><span class="line">                hm.put(nums[i],1);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                int c=hm.get(nums[i])+1;</span><br><span class="line">                hm.put(nums[i],c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int k;</span><br><span class="line">        Map.Entry&lt;Integer,Integer&gt; element=null;</span><br><span class="line">        for(Map.Entry&lt;Integer,Integer&gt; entry: hm.entrySet())&#123;</span><br><span class="line"></span><br><span class="line">            if(entry.getValue()&gt;count)&#123;</span><br><span class="line">                element=entry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return element.getKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="…进阶版（Boyer-Moore-投票算法）"><a href="#…进阶版（Boyer-Moore-投票算法）" class="headerlink" title="…进阶版（Boyer-Moore 投票算法）"></a>…进阶版（Boyer-Moore 投票算法）</h2><p>时间复杂度为O（n），空间复杂度为O（1）；<br>思路：<br>如果我们把众数记为 +1+1+1，把其他数记为 −1-1−1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。<br>（与众数不同的元素个数肯定大于众数的数量！）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int majorityElement(int[] nums) &#123;</span><br><span class="line">        //摩尔计数</span><br><span class="line">        int candicate=nums[0];</span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            //简化：count+=（candicate==nums[i]）？1:-1；</span><br><span class="line">            if(count!=0)&#123;</span><br><span class="line">                if(candicate==nums[i])&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                candicate=nums[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return candicate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189.轮转数组"></a>189.轮转数组</h1><h2 id="…法1使用额外数组"><a href="#…法1使用额外数组" class="headerlink" title="…法1使用额外数组"></a>…法1使用额外数组</h2><p>相当于每个元素往后移动k个位置，超出数组长度的则取余数。然后拷贝到原来的数组<br>注意：<strong>System.arraycopy():复制数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void rotate(int[] nums, int k) &#123;</span><br><span class="line">        int n=nums.length;</span><br><span class="line">        int[] result=new int[n];</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            result[(i+k)%n]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(result,0,nums,0,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="…法2环形替换"><a href="#…法2环形替换" class="headerlink" title="…法2环形替换"></a>…法2环形替换</h2><p>求最大公约数gcd(看不懂，直接用的count计数，当遍历的元素个数等于数组长度时，停止循环)<br><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/zyx_images/202401171419431.png"><br>对于每个元素，循环一圈会回到原点（终止循环）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void rotate(int[] nums, int k) &#123;</span><br><span class="line">        int n=nums.length;</span><br><span class="line">        //当k比n长的时候，需要取模</span><br><span class="line">        k=k%n;</span><br><span class="line">        //直接记录元素</span><br><span class="line">        int count=0;</span><br><span class="line">        for(int start=0;;start++)&#123;</span><br><span class="line">            if(count==n)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            int current=start;</span><br><span class="line">            int prev=nums[start];</span><br><span class="line">            //一圈</span><br><span class="line">            do&#123;</span><br><span class="line">                int next=(current+k)%n;</span><br><span class="line">                int temp=nums[next];</span><br><span class="line">                nums[next]=prev;</span><br><span class="line">                prev=temp;</span><br><span class="line">                current=next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;while(current!=start);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="…法3翻转数组"><a href="#…法3翻转数组" class="headerlink" title="…法3翻转数组"></a>…法3翻转数组</h2><p><img src="https://dzc2000919.oss-cn-shanghai.aliyuncs.com/zyx_images/202401171422211.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void rotate(int[] nums, int k) &#123;</span><br><span class="line">        k%=nums.length;</span><br><span class="line">        reverse(nums,0,nums.length-1);</span><br><span class="line">        reverse(nums,0,k-1);</span><br><span class="line">        reverse(nums,k,nums.length-1);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    public void reverse(int[] nums,int start,int end)&#123;</span><br><span class="line">        while(start&lt;end)&#123;</span><br><span class="line">            int t=nums[start];</span><br><span class="line">            nums[start]=nums[end];</span><br><span class="line">            nums[end]=t;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="121-买卖股票的最佳时间"><a href="#121-买卖股票的最佳时间" class="headerlink" title="121.买卖股票的最佳时间"></a>121.买卖股票的最佳时间</h1><p>动态规划（<strong>空间换时间</strong>）（Dynamic programming，简称DP）是一种将复杂问题分解成很多子问题，并将子问题的求解结果存储起来避免重复求解的一种算法。</p>
<ul>
<li>最优子结构性质（一个最优化策略的子策略总是最优的<br>）</li>
<li>无后效性，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态</li>
<li>子问题的重叠性，用空间将这些子问题的解存储下来，避免重复求解相同的子问题</li>
</ul>
<p>（只能选某一天）<br>需要在最低点买入，最高点卖出<br>分成若干个子阶段，用一个dp数组记录前i天的最低价格，然后求当前的盈利。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int n=prices.length;</span><br><span class="line">        int[] dp=new int[n];//记录前i天的最小价格</span><br><span class="line">        dp[0]=prices[0];</span><br><span class="line">        int result=0;</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            if(dp[i-1]&lt;prices[i])&#123;</span><br><span class="line">                dp[i]=dp[i-1];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[i]=prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            if(prices[i]-dp[i-1]&gt;result)&#123;</span><br><span class="line">                    result=prices[i]-dp[i-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="122-买卖股票的最佳时间2"><a href="#122-买卖股票的最佳时间2" class="headerlink" title="122.买卖股票的最佳时间2"></a>122.买卖股票的最佳时间2</h1><p>只要股票递增都可以买，如果递减，则当天卖出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int n=prices.length;</span><br><span class="line">        int buy=prices[0];</span><br><span class="line">        int result=0;</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            if(prices[i]&gt;buy)&#123;</span><br><span class="line">                result+=prices[i]-buy;</span><br><span class="line">            &#125;</span><br><span class="line">                buy=prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55.跳跃游戏"></a>55.跳跃游戏</h1><p>依次遍历，考虑每个位置能到达的最远位置；当当前位置小于上一个位置到达的最远位置，即可以继续跳跃，直到能到达最后一个元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canJump(int[] nums) &#123;</span><br><span class="line">        int n=nums.length;</span><br><span class="line">        int farmost=nums[0];</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            if(farmost&gt;=i)&#123;</span><br><span class="line">                farmost=(farmost&lt;i+nums[i])?(i+nums[i]):farmost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(farmost&lt;n-1)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="45-跳跃游戏2"><a href="#45-跳跃游戏2" class="headerlink" title="45.跳跃游戏2"></a>45.跳跃游戏2</h1><p>动态规划：时间空间复杂度较高<br>第i个点肯定是从前（0～i-1）得到的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int jump(int[] nums) &#123;</span><br><span class="line">        int n=nums.length;</span><br><span class="line">        int[] dp=new int[n];//记录到达该点的最小次数；</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i]=n;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0]=0;</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">                if(j+nums[j]&gt;=i)&#123;</span><br><span class="line">                    dp[i]=dp[i]&lt;dp[j]+1?dp[i]:dp[j]+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这个题，一定能到所以nums[i]中的都能跳，当然跳最远的。？？<br>能够到达的最远边界，以那个边界为起点，step++</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int jump(int[] nums) &#123;</span><br><span class="line">        int n=nums.length;</span><br><span class="line">        int maxpos=0;</span><br><span class="line">        int step=0;</span><br><span class="line">        int end=0;</span><br><span class="line">        //最后一次一定超出最后一个元素，不用便利，否则到不了</span><br><span class="line">        for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">            if(maxpos&lt;i+nums[i])&#123;</span><br><span class="line">                maxpos=i+nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">             //上次的边界</span><br><span class="line">            if(i==end)&#123;</span><br><span class="line">                end=maxpos;</span><br><span class="line">                step++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="274-H指数"><a href="#274-H指数" class="headerlink" title="274.H指数"></a>274.H指数</h1><h2 id="法1-排序"><a href="#法1-排序" class="headerlink" title="..法1:排序"></a>..法1:排序</h2><p>相当于找大于h引用数量的论文至少有h篇，<br>引用数量大肯定的满足，然后依次增加h指数，直到不满足要求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int hIndex(int[] citations) &#123;</span><br><span class="line">        int h=0;</span><br><span class="line">        int i=citations.length-1;</span><br><span class="line">        Arrays.sort(citations);</span><br><span class="line">        //从末尾看，依次增加h</span><br><span class="line">        while(i&gt;=0&amp;&amp;citations[i]&gt;h)&#123;</span><br><span class="line">            i--;</span><br><span class="line">            h++;</span><br><span class="line">        &#125;</span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法二计数排序"><a href="#法二计数排序" class="headerlink" title="..法二计数排序"></a>..法二计数排序</h2><p><strong>降低时间复杂度为n，空间复杂度增加</strong><br>需要额外的计数数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int hIndex(int[] citations) &#123;</span><br><span class="line">       //由于引用次数大于发表次数的不可能为h指数，可以将其计数为n</span><br><span class="line">       //节约数组空间为0-n,n+1</span><br><span class="line">       int n=citations.length;</span><br><span class="line">       int[] count=new int[n+1];</span><br><span class="line">       int total=0;</span><br><span class="line">       for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">           if(citations[i]&gt;n)&#123;</span><br><span class="line">               count[n]++;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               count[citations[i]]++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //找h篇论文引用大于h次</span><br><span class="line">       //从末尾找，n是论文总篇数</span><br><span class="line">       for(int i=n;i&gt;=0;i--)&#123;</span><br><span class="line">           total+=count[i];</span><br><span class="line">           if(total&gt;=i)&#123;</span><br><span class="line">               return i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="法三二分查找"><a href="#法三二分查找" class="headerlink" title="..法三二分查找"></a>..法三二分查找</h2><p><strong>时间复杂度nlogn，空间复杂度为1</strong></p>
<blockquote>
<blockquote>
<p>表示二进制右移，低位舍弃，除2</p>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int hIndex(int[] citations) &#123;</span><br><span class="line">       //h指数的范围是0-n</span><br><span class="line">       //小于等于h 的都满足，大于h的不满足，则用二分搜索（有序）</span><br><span class="line">       int left=0,right=citations.length;</span><br><span class="line">       int mid=0;</span><br><span class="line">       int cnt=0;</span><br><span class="line">       while(left&lt;right)&#123;</span><br><span class="line">           //left和right相等时，死循环，+1防止</span><br><span class="line">           mid=(left+right+1)&gt;&gt;1;</span><br><span class="line">           cnt=0;</span><br><span class="line">           //大于mid的数量</span><br><span class="line">           for(int i=0;i&lt;citations.length;i++)&#123;</span><br><span class="line">               if(citations[i]&gt;=mid)&#123;</span><br><span class="line">                   cnt++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           //大于mid的篇数多，h值可以增加，【mid,right】</span><br><span class="line">           if(cnt&gt;=mid)&#123;</span><br><span class="line">               left=mid;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               //大于mid的篇数少，h要减少【left，mid】</span><br><span class="line">               right=mid-1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //right不一定满足</span><br><span class="line">       return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="380-O-1-时间插入、删除和获取随机元素"><a href="#380-O-1-时间插入、删除和获取随机元素" class="headerlink" title="380.O(1)时间插入、删除和获取随机元素"></a>380.O(1)时间插入、删除和获取随机元素</h1><p>变长数组能在O(1)获取元素，但插入和删除在哈希表可以。则结合两种结构：<strong>数组存储元素，哈希表记录元素的下标</strong><br>containsKey!!!!</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class RandomizedSet &#123;</span><br><span class="line">    List&lt;Integer&gt; nums;</span><br><span class="line">    Map&lt;Integer,Integer&gt; elements;</span><br><span class="line">    Random random;</span><br><span class="line"></span><br><span class="line">    public RandomizedSet() &#123;</span><br><span class="line">        nums=new ArrayList&lt;Integer&gt;();</span><br><span class="line">        elements=new  HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        random=new Random();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean insert(int val) &#123;</span><br><span class="line">        //元素存在</span><br><span class="line">        if(elements.containsKey(val))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int index=nums.size();</span><br><span class="line">        nums.add(val);</span><br><span class="line">        elements.put(val,index);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean remove(int val) &#123;</span><br><span class="line">        if(!elements.containsKey(val))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int index=elements.get(val);</span><br><span class="line">        int last=nums.get(nums.size()-1);</span><br><span class="line">        nums.set(index,last);</span><br><span class="line">        elements.put(last,index);</span><br><span class="line">        nums.remove(nums.size()-1);</span><br><span class="line">        elements.remove(val);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getRandom() &#123;</span><br><span class="line">        int randomIndex=random.nextInt(nums.size());</span><br><span class="line">        return nums.get(randomIndex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your RandomizedSet object will be instantiated and called as such:</span><br><span class="line"> * RandomizedSet obj = new RandomizedSet();</span><br><span class="line"> * boolean param_1 = obj.insert(val);</span><br><span class="line"> * boolean param_2 = obj.remove(val);</span><br><span class="line"> * int param_3 = obj.getRandom();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h1 id="283-除自身以外数组的乘积"><a href="#283-除自身以外数组的乘积" class="headerlink" title="283.除自身以外数组的乘积"></a>283.除自身以外数组的乘积</h1><h2 id="法1左右乘积列表"><a href="#法1左右乘积列表" class="headerlink" title="..法1左右乘积列表"></a>..法1左右乘积列表</h2><p>利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案.得到left和right数组即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] productExceptSelf(int[] nums) &#123;</span><br><span class="line">        int n=nums.length;</span><br><span class="line">        int[] left=new int[n];</span><br><span class="line">        int[] right=new int[n];</span><br><span class="line">        int[] answers=new int[n];</span><br><span class="line">        left[0]=1;</span><br><span class="line">        left[1]=nums[0];</span><br><span class="line">        right[n-1]=1;</span><br><span class="line">        right[n-2]=nums[n-1];</span><br><span class="line">        for(int i=2;i&lt;n;i++)&#123;</span><br><span class="line">            left[i]=left[i-1]*nums[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=n-3;i&gt;=0;i--)&#123;</span><br><span class="line">            right[i]=right[i+1]*nums[i+1];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            answers[i]=left[i]*right[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return answers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="法二空间复杂度O-1"><a href="#法二空间复杂度O-1" class="headerlink" title="..法二空间复杂度O(1)"></a>..法二空间复杂度O(1)</h2><p>输出数组不算在空间复杂度内，那么我们可以将L用输出数组来计算，然后用一个变量r表示右侧元素之和，直接乘在输出数组上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] productExceptSelf(int[] nums) &#123;</span><br><span class="line">        int length=nums.length;</span><br><span class="line">        int[] answer=new int[length];</span><br><span class="line">        answer[0]=1;</span><br><span class="line">        //左边</span><br><span class="line">        for(int i=1;i&lt;length;i++)&#123;</span><br><span class="line">            answer[i]=answer[i-1]*nums[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        //右边</span><br><span class="line">        int r=1;</span><br><span class="line">        for(int i=length-1;i&gt;=0;i--)&#123;</span><br><span class="line">            answer[i]=answer[i]*r;</span><br><span class="line">            r*=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134.加油站"></a>134.加油站</h1><p>从 x,y 之间的任何一个加油站出发，都无法到达加油站 y 的下一个加油站。<br>从0坐标开始，最远到达y，从y+1开始作为起点检查，减少检查的次数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">        //从0开始。</span><br><span class="line">        //尽可能减少检查起点的个数</span><br><span class="line">        int n=gas.length;</span><br><span class="line">        int i=0;</span><br><span class="line">        while(i&lt;n)&#123;</span><br><span class="line">            int gasSum=0,costSum=0;</span><br><span class="line">            int farStation=0;//过去的站数</span><br><span class="line">            while(farStation&lt;n)&#123;</span><br><span class="line">                //路线为环形，所以会回到0坐标，需要取模</span><br><span class="line">                int j=(i+farStation)%n;</span><br><span class="line">                gasSum+=gas[j];</span><br><span class="line">                costSum+=cost[j];</span><br><span class="line">                if(gasSum&lt;costSum)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    farStation++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //绕了一圈</span><br><span class="line">            if(farStation==n)&#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                i=i+farStation+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="135-分发糖果（难）"><a href="#135-分发糖果（难）" class="headerlink" title="135.分发糖果（难）"></a>135.分发糖果（难）</h1><p>两次循环，分别满足左规则（该元素和左侧元素）和右规则，然后取该元素最大值，同时满足左右规则<br>空间复杂度O(n),时间复杂度O(n)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int candy(int[] ratings) &#123;</span><br><span class="line">        int n=ratings.length;</span><br><span class="line">        int[] candy=new int[n];</span><br><span class="line">        //满足左规则，该元素大于左侧元素</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            if(i&gt;0&amp;&amp;ratings[i-1]&lt;ratings[i])&#123;</span><br><span class="line">                candy[i]=candy[i-1]+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                candy[i]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //满足右规则,该元素和该元素右侧的元素</span><br><span class="line">        int r=0;</span><br><span class="line">        int result=0;</span><br><span class="line">        for(int i=n-1;i&gt;=0;i--)&#123;</span><br><span class="line">            if(i&lt;n-1&amp;&amp;ratings[i+1]&lt;ratings[i])&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                r=1;</span><br><span class="line">            &#125;</span><br><span class="line">            //最大值同时满足左右规则</span><br><span class="line">            result+= r&gt;candy[i]?r:candy[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>常数级空间</strong><br>记录递增序列和递减序列的长度，对于递减序列，逐渐加1即可；对于递减序列，当前分为1，所有元素加一<br>注意当dec等于inc时，需要将最后一个元素归为递减中，dec++<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int candy(int[] ratings) &#123;</span><br><span class="line">        int n=ratings.length;</span><br><span class="line">        int result=1;</span><br><span class="line">        int inc=1,dec=0,pre=1;</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            if(ratings[i]&gt;=ratings[i-1])&#123;</span><br><span class="line">                dec=0;</span><br><span class="line">                pre=ratings[i]==ratings[i-1]?1:pre+1;</span><br><span class="line">                result+=pre;</span><br><span class="line">                inc=pre;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dec++;</span><br><span class="line">                if(dec==inc)&#123;</span><br><span class="line">                    dec++;//将递增序列最后一个归为递减序列</span><br><span class="line">                &#125;</span><br><span class="line">                result+=dec;</span><br><span class="line">                pre=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a>42.接雨水</h1><h2 id="法1动态规划"><a href="#法1动态规划" class="headerlink" title="..法1动态规划"></a>..法1动态规划</h2><p>下雨后水能到达的最大高度等于下标i两边的最大高度的最小值<br>分别遍历每个下标i左边的最高高度，右侧的最高高度，<br>然后取最小，减去实际高度<br>O（n）；O（n）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int trap(int[] height) &#123;</span><br><span class="line">        int n=height.length;</span><br><span class="line">        int[] leftmax=new int[n];</span><br><span class="line">        leftmax[0]=height[0];</span><br><span class="line">        int[] rightmax=new int[n];</span><br><span class="line">        rightmax[n-1]=height[n-1];</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            leftmax[i]=leftmax[i-1]&lt;height[i]?height[i]:leftmax[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=n-2;i&gt;=0;i--)&#123;</span><br><span class="line">            rightmax[i]=rightmax[i+1]&lt;height[i]?height[i]:rightmax[i+1];</span><br><span class="line">        &#125;</span><br><span class="line">         for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            int minelement=leftmax[i]&gt;rightmax[i]?rightmax[i]:leftmax[i];</span><br><span class="line">            sum+=minelement-height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="法2单调栈"><a href="#法2单调栈" class="headerlink" title="..法2单调栈"></a>..法2单调栈</h2><p>O（n）；O（n）</p>
<h2 id="法3双指针（重要）"><a href="#法3双指针（重要）" class="headerlink" title="..法3双指针（重要）"></a>..法3双指针（重要）</h2><p>O（n）；空间复杂度O（1）<br>left和right指针遍历，leftmax和rightmax分别表示当前位置最大元素，<br>比较height[left],height[right]，小的才能移动，大的需要继续被比较</p>
<h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13.罗马数字转整数"></a>13.罗马数字转整数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    //匿名类双括号初始化（耗内存）</span><br><span class="line">        Map&lt;Character,Integer&gt; ourMap=new HashMap&lt;Character,Integer&gt;()&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                put(&#x27;I&#x27;,1);</span><br><span class="line">                put(&#x27;V&#x27;, 5);</span><br><span class="line">                put(&#x27;X&#x27;, 10);</span><br><span class="line">                put(&#x27;L&#x27;, 50);</span><br><span class="line">                put(&#x27;C&#x27;, 100);</span><br><span class="line">                put(&#x27;D&#x27;, 500);</span><br><span class="line">                put(&#x27;M&#x27;, 1000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    public int romanToInt(String s) &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        int n=s.length();</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            int value=ourMap.get(s.charAt(i));</span><br><span class="line">            if(i&lt;n-1&amp;&amp;value&lt;ourMap.get(s.charAt(i+1)))&#123;</span><br><span class="line">                ans-=value;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                ans+=value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12.整数转罗马数字"></a>12.整数转罗马数字</h1><p>StringBuffer多线程，线程安全<br>toString 转化为String</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int[] values = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;;</span><br><span class="line">    String[] symbols = &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;;</span><br><span class="line">    public String intToRoman(int num) &#123;</span><br><span class="line">        StringBuffer roman=new StringBuffer();</span><br><span class="line">        for(int i=0;i&lt;values.length;i++)&#123;</span><br><span class="line">            while(values[i]&lt;=num)&#123;</span><br><span class="line">                num-=values[i];</span><br><span class="line">                roman.append(symbols[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(num==0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //StringBuffer转化成字符串</span><br><span class="line">        return roman.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58.最后一个单词的长度"></a>58.最后一个单词的长度</h1><p>先过滤掉末尾的空格，再获取末尾的单词长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLastWord(String s) &#123;</span><br><span class="line">       int end=s.length()-1;</span><br><span class="line">       while(end&gt;=0&amp;&amp;s.charAt(end)==&#x27; &#x27;) end--;</span><br><span class="line">       if(end&lt;0) return 0;</span><br><span class="line">       int start=end;</span><br><span class="line">       while(start&gt;=0&amp;&amp;s.charAt(start)!=&#x27; &#x27;)start--;</span><br><span class="line">       return end-start;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLastWord(String s) &#123;</span><br><span class="line">       String[] str=s.split(&quot; &quot;);</span><br><span class="line">       return str[str.length-1].length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14.最长公共前缀"></a>14.最长公共前缀</h1><p>横向扫描：<br>遍历每个字符串数组的元素，以第一个元素为最长前缀，不匹配，则更新最长前缀。</p>
<p>纵向扫描：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        String string=strs[0];</span><br><span class="line">        for(int i=0;i&lt;string.length();i++)&#123;</span><br><span class="line">            char letter=string.charAt(i);</span><br><span class="line">            for(int j=0;j&lt;strs.length;j++)&#123;</span><br><span class="line">                if(strs[j].length()==0)&#123;</span><br><span class="line">                    return &quot;&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                if(i==strs[j].length()||strs[j].charAt(i) !=letter)&#123;</span><br><span class="line">                   return string.substring(0,i);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151.反转字符串中的单词"></a>151.反转字符串中的单词</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        //除去开头和末尾的空白字符</span><br><span class="line">        s=s.trim();</span><br><span class="line">        //使用正则式分割(array数组转化为list)</span><br><span class="line">        List&lt;String&gt; wordlist=Arrays.asList(s.split(&quot;\\s+&quot;));</span><br><span class="line">        Collections.reverse(wordlist);</span><br><span class="line">        return String.join(&quot; &quot;,wordlist);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法2:自定义函数，去掉首尾的空格，reverse整个字符串，然后单独reverse每个单词；<br>public void reverse(StringBuilder sb, int left, int right) </p>
<p>法3:双端队列（Deque接口，ArrayDeque实现类）<br>&#x2F;&#x2F; 将单词 push 到队列的头部<br>d.offerFirst(word.toString());<br>word.setLength(0);</p>
<h1 id="6-Z子形变换"><a href="#6-Z子形变换" class="headerlink" title="6.Z子形变换"></a>6.Z子形变换</h1><p>法1:二维数组（不推荐）<br>法2：压缩矩阵空间。<strong>组成答案时只会用到每行的非空字符</strong>。将矩阵的每行初始化为一个<strong>空列表</strong>，每次向某一行添加字符时，添加到该行的列表末尾即可。<br>需要知道周期，并且先增加后递减添加的列表下标。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String convert(String s, int numRows) &#123;</span><br><span class="line">        int n=s.length();</span><br><span class="line">        if(numRows==1 || numRows==n)&#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer[] mat=new StringBuffer[numRows];</span><br><span class="line">        for(int i=0;i&lt;numRows;i++)&#123;</span><br><span class="line">            mat[i]=new StringBuffer();</span><br><span class="line">        &#125;</span><br><span class="line">        //周期容易观察</span><br><span class="line">        for(int i=0,x=0,t=2*numRows-2;i&lt;n;i++)&#123;</span><br><span class="line">            mat[x].append(s.charAt(i));</span><br><span class="line">            if(i%t&lt;numRows-1)&#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                x--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer ans=new StringBuffer();</span><br><span class="line">        for(StringBuffer row:mat)&#123;</span><br><span class="line">            ans.append(row);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>法3:直接构造。（空间复杂度O（1））（未看）</p>
<h1 id="28-找出字符串中第一个匹配的下标"><a href="#28-找出字符串中第一个匹配的下标" class="headerlink" title="28.找出字符串中第一个匹配的下标"></a>28.找出字符串中第一个匹配的下标</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int strStr(String haystack, String needle) &#123;</span><br><span class="line">        int flag;</span><br><span class="line">        for(int i=0;i&lt;=haystack.length()-needle.length();i++)&#123;</span><br><span class="line">            flag=1;</span><br><span class="line">            for(int j=0;j&lt;needle.length();j++)&#123;</span><br><span class="line">                if(haystack.charAt(i+j)!=needle.charAt(j))&#123;</span><br><span class="line">                    flag=0;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag==1)&#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>法二：kmp？？？？不懂</p>
<h1 id="68-文本左右对齐"><a href="#68-文本左右对齐" class="headerlink" title="68.文本左右对齐"></a>68.文本左右对齐</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; fullJustify(String[] words, int maxWidth) &#123;</span><br><span class="line">        List&lt;String&gt; ans=new ArrayList&lt;String&gt;();</span><br><span class="line">        int right=0,n=words.length;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            int sumLen=0;</span><br><span class="line">            int left=right;//该行的第一个单词的下标</span><br><span class="line">            //一行最多放多少单词,且至少放一个空格</span><br><span class="line">            while(right&lt;n&amp;&amp;sumLen+words[right].length()+right-left&lt;=maxWidth)&#123;</span><br><span class="line">                sumLen+=words[right].length();</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            //若为最后一行</span><br><span class="line">            if(right==n)&#123;</span><br><span class="line">                StringBuffer sb=join(words,left,n,&quot; &quot;);</span><br><span class="line">                sb.append(blank(maxWidth-sb.length()));</span><br><span class="line">                ans.add(sb.toString());</span><br><span class="line">                return ans;</span><br><span class="line">            &#125;</span><br><span class="line">            //若为中间行，只有一个单词</span><br><span class="line">            int numwords=right-left;</span><br><span class="line">            int numspace=maxWidth-sumLen;</span><br><span class="line">            if(numwords==1)&#123;</span><br><span class="line">                StringBuffer sb=new StringBuffer(words[left]);</span><br><span class="line">                sb.append(blank(numspace));</span><br><span class="line">                ans.add(sb.toString());</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //若为中间行，多个单词</span><br><span class="line">            //4个单词，3个间隔</span><br><span class="line">            int avg=numspace/(numwords-1);</span><br><span class="line">            int extra=numspace%(numwords-1);</span><br><span class="line">            StringBuffer sb=new StringBuffer();</span><br><span class="line">            //前xx个平均空格加1；</span><br><span class="line">            sb.append(join(words,left,left+extra+1,blank(avg+1)));</span><br><span class="line">            sb.append(blank(avg));</span><br><span class="line">            sb.append(join(words,left+extra+1,right,blank(avg)));</span><br><span class="line">            ans.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //返回长度为n的空格字符串</span><br><span class="line">    public String blank(int n)&#123;</span><br><span class="line">        StringBuffer sb=new StringBuffer();</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            sb.append(&#x27; &#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    //join返回拼接【left，right】范围的words组成的字符串(及间隔的空格字符串)</span><br><span class="line">    public  StringBuffer join(String[] words,int left,int right,String seq)&#123;</span><br><span class="line">        StringBuffer sb=new StringBuffer(words[left]);</span><br><span class="line">        for(int i=left+1;i&lt;right;i++)&#123;</span><br><span class="line">            sb.append(seq);</span><br><span class="line">            sb.append(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125.验证回文串"></a>125.验证回文串</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isPalindrome(String s) &#123;</span><br><span class="line">        int left=0,right=s.length()-1;</span><br><span class="line">        while(left&lt;right)&#123;</span><br><span class="line">            while(left&lt;right&amp;&amp;!Character.isLetterOrDigit(s.charAt(left)))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            while(right&gt;left&amp;&amp;!Character.isLetterOrDigit(s.charAt(right)))&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            if(Character.toLowerCase(s.charAt(left))!=Character.toLowerCase(s.charAt(right)))&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392.判断子序列"></a>392.判断子序列</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSubsequence(String s, String t) &#123;</span><br><span class="line">     int slow=0,fast=0;</span><br><span class="line">     while(slow&lt;s.length()&amp;&amp;fast&lt;t.length())&#123;</span><br><span class="line">         if(s.charAt(slow)==t.charAt(fast))&#123;</span><br><span class="line">             slow++;</span><br><span class="line">         &#125;</span><br><span class="line">         fast++;</span><br><span class="line">     &#125;</span><br><span class="line">     return slow==s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      </div>
    </div>
  </article>
  <div class="post__foot">
    
    <div class="post-nav">
  
    <a class="post-nav-item-left" href="/2024/01/18/Maven/">
      <div class="text-align">
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596"/>
        </svg>
        <span class="text-small">上一篇</span>
      </div>
      <div>Maven</div>
    </a>
  
  <div class="vhr"></div>
  
    <a class="post-nav-item-right" href="/2024/01/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">
      <div class="text-align">
        <span class="text-small">下一篇</span>
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             transform="scale(-1,-1)"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596"/>
        </svg>
      </div>
      网络编程
    </a>
  
</div>

    
      <div class="related-post">
  <div class="related__head">
  <a href="/tags/LeetCode/" class="post-tag">#LeetCode</a><a href="/tags/%E6%95%B0%E7%BB%84/" class="post-tag">#数组</a>

</div>
  <div class="realated__body">
    
      DEBUG: 请安装插件 <a target="_blank" rel="noopener" href="https://github.com/tea3/hexo-related-popular-posts">hexo-related-popular-posts</a> 或关闭 related_post 配置!
    
  </div>
</div>

    
    
  </div>

    </div>
    <div class="foot">
      <div class="foot-inner">
        <div class="foot__head">
          
            <div class="foot-line">
              
                <div class="matts">若</div>
              
                <div class="matts">无</div>
              
                <div class="matts">闲</div>
              
                <div class="matts">事</div>
              
                <div class="matts">挂</div>
              
                <div class="matts">心</div>
              
                <div class="matts">头</div>
              
            </div>
          
            <div class="foot-line">
              
                <div class="matts">便</div>
              
                <div class="matts">是</div>
              
                <div class="matts">人</div>
              
                <div class="matts">间</div>
              
                <div class="matts">好</div>
              
                <div class="matts">时</div>
              
                <div class="matts">节</div>
              
            </div>
          
        </div>
        <div class="foot__body">
          
            <div class="foot-item">
              <div class="foot-item__head">朋友</div>
              <div class="foot-item__body">
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/icon/icon-link.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://carriemint.github.io">芋圆的主页</a>
                  </div>
                
                <div class="text">
                  <img alt="link" height="20px" width="20px" src="/images/icon/icon-link+.svg"/>
                  <a class="foot-link"
                     href="mailto:863162796@qq.com?subject=%E7%94%B3%E8%AF%B7%20Hozen.site%20%E7%9A%84%E5%8F%8B%E9%93%BE%E4%BD%8D%E7%BD%AE">
                  申请友链</a>
                </div>
              </div>
            </div>
          
          
            <div class="foot-item">
              <div class="foot-item__head">账号</div>
              <div class="foot-item__body">
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/logo-github.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://github.com/carriemint">carriemint</a>
                  </div>
                
              </div>
            </div>
          
          <div class="foot-item">
            <div class="foot-item__head">联系</div>
            <div class="foot-item__body">
              <div class="text">
                <img alt="link" height="20px" width="20px" src="/images/icon/icon-email.svg"/>
                <a class="foot-link" href="mailto:863162796@qq.com">863162796@qq.com</a>
              </div>
            </div>
          </div>
        </div>
        <div class="copyright">
          <a href="http://example.com">芋圆明天不困</a> &nbsp;|&nbsp;由&nbsp;<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>&nbsp;及&nbsp;
          <svg width="20" height="20" viewBox="0 0 725 725">
            <path fill-rule="evenodd" fill="rgb(221, 221, 221)" d="M145.870,236.632 L396.955,103.578 L431.292,419.44 L156.600,522.53 L145.870,236.632 Z"/>
            <path fill-rule="evenodd" fill="rgb(159, 159, 159)" d="M396.955,103.578 L564.345,234.486 L611.558,513.469 L431.292,419.44 L396.955,103.578 Z"/>
            <path fill-rule="evenodd" fill="rgb(0, 0, 0)" d="M431.292,419.44 L611.558,513.469 L358.327,595.18 L156.600,522.53 L431.292,419.44 Z"/>
          </svg>
          <a target="_blank" rel="noopener" href="https://github.com/hooozen/hexo-theme-tranquility">致远</a>&nbsp;驱动
        </div>
      </div>
    </div>
    
    
  

  </body>
</html>